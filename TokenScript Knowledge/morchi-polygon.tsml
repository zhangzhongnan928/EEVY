<ts:token xmlns:ethereum="urn:ethereum:constantinople" xmlns:ts="http://tokenscript.org/2024/01/tokenscript" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="MORCHI" xsi:schemaLocation="http://tokenscript.org/2024/01/tokenscript https://www.tokenscript.org/schemas/2024-01/tokenscript.xsd">
	<ts:label>
		<ts:plurals xml:lang="en">
			<ts:string quantity="one">MORCHI</ts:string>
		</ts:plurals>
	</ts:label>
	<ts:meta>
		<ts:description xml:lang="en">MORCHI is a fun, on-chain mini game that promotes healthy habits and allows users to earn and collect rewards daily. Your MORCHI NFT will also give you priority access to events and experiences. Developed by FSL on the Polygon Network, MORCHI showcases the potential of Smart Layer technology on the MOOAR Marketplace.</ts:description>
		<ts:aboutUrl xml:lang="en">https://morchi.mooar.com/</ts:aboutUrl>
		<ts:iconUrl xml:lang="en">https://resources.smartlayer.network/smart-token-store/images/morchi.png</ts:iconUrl>
	</ts:meta>
	<ts:contract interface="erc721" name="Token">
		
		
		
		<ts:address network="137">0xB48f53010Acbc0E24D3D12D892E2215879e6fD13</ts:address>
		<ts:abi>
			
			[
				{
				  "inputs": [
					{
					  "internalType": "uint256",
					  "name": "tokenId",
					  "type": "uint256"
					}
				  ],
				  "name": "getApproved",
				  "outputs": [
					{
					  "internalType": "address",
					  "name": "",
					  "type": "address"
					}
				  ],
				  "stateMutability": "view",
				  "type": "function"
				}
			]
			
		</ts:abi>
	</ts:contract>
	<ts:contract name="MorchiScore">
		
		
		
		<ts:address network="137">0xBAB028f7ac84EB4A90BC4eE5c3725437fFbA806e</ts:address>
		<ts:abi>
			
			[
				{
				  "inputs": [
					{
					  "internalType": "uint256",
					  "name": "tokenId",
					  "type": "uint256"
					}
				  ],
				  "name": "getMorchiInfo",
				  "outputs": [
					{
					  "components": [
						{
						  "components": [
							{
							  "internalType": "uint8",
							  "name": "level",
							  "type": "uint8"
							},
							{
							  "internalType": "bool",
							  "name": "hasDrunk",
							  "type": "bool"
							},
							{
							  "internalType": "bool",
							  "name": "hasShowered",
							  "type": "bool"
							},
							{
							  "internalType": "bool",
							  "name": "hasWorkedOut",
							  "type": "bool"
							},
							{
							  "internalType": "bool",
							  "name": "hasLeveledUp",
							  "type": "bool"
							},
							{
							  "internalType": "uint256",
							  "name": "firstTaskTime",
							  "type": "uint256"
							},
							{
							  "internalType": "uint256",
							  "name": "pointsBalance",
							  "type": "uint256"
							}
						  ],
						  "internalType": "struct MorchiGame.MorchiState",
						  "name": "state",
						  "type": "tuple"
						},
						{
						  "internalType": "bool",
						  "name": "canDrink",
						  "type": "bool"
						},
						{
						  "internalType": "bool",
						  "name": "canShower",
						  "type": "bool"
						},
						{
						  "internalType": "bool",
						  "name": "canWorkOut",
						  "type": "bool"
						},
						{
						  "internalType": "bool",
						  "name": "canLevelUp",
						  "type": "bool"
						}
					  ],
					  "internalType": "struct MorchiGame.MorchiInfo",
					  "name": "",
					  "type": "tuple"
					}
				  ],
				  "stateMutability": "view",
				  "type": "function"
				},
				{
				  "inputs": [
					{
					  "internalType": "uint256",
					  "name": "",
					  "type": "uint256"
					}
				  ],
				  "name": "LEVEL_UP_COST",
				  "outputs": [
					{
					  "internalType": "uint256",
					  "name": "",
					  "type": "uint256"
					}
				  ],
				  "stateMutability": "view",
				  "type": "function"
				},
				{
				  "inputs": [
					{
					  "internalType": "uint256",
					  "name": "",
					  "type": "uint256"
					}
				  ],
				  "name": "TASK_POINTS",
				  "outputs": [
					{
					  "internalType": "uint256",
					  "name": "",
					  "type": "uint256"
					}
				  ],
				  "stateMutability": "view",
				  "type": "function"
				}
			]
			
		</ts:abi>
	</ts:contract>
	<ts:contract name="SUTToken">
		
		
		
		
		<ts:address network="137">0x57211299bc356319ba5ca36873eb06896173f8bc</ts:address>
		<ts:abi>
			
			[
				{
					"constant": true,
					"inputs": [
						{
							"name": "_owner",
							"type": "address"
						}
					],
					"name": "balanceOf",
					"outputs": [
						{
							"name": "balance",
							"type": "uint256"
						}
					],
					"payable": false,
					"stateMutability": "view",
					"type": "function"
				},
				{
					"inputs": [
						{
						  "internalType": "address",
						  "name": "owner",
						  "type": "address"
						},
						{
						  "internalType": "address",
						  "name": "spender",
						  "type": "address"
						}
					],
					"name": "allowance",
					"outputs": [
						{
						  "internalType": "uint256",
						  "name": "",
						  "type": "uint256"
						}
					],
					"stateMutability": "view",
					"type": "function"
				}
			]
			
		</ts:abi>
	</ts:contract>
	<ts:contract name="GMTToken">
		<ts:address network="137">0x714DB550b574b3E927af3D93E26127D15721D4C2</ts:address>
		<ts:abi>
			
			[
				{
					"constant": true,
					"inputs": [
						{
							"name": "_owner",
							"type": "address"
						}
					],
					"name": "balanceOf",
					"outputs": [
						{
							"name": "balance",
							"type": "uint256"
						}
					],
					"payable": false,
					"stateMutability": "view",
					"type": "function"
				},
				{
					"inputs": [
						{
						  "internalType": "address",
						  "name": "owner",
						  "type": "address"
						},
						{
						  "internalType": "address",
						  "name": "spender",
						  "type": "address"
						}
					],
					"name": "allowance",
					"outputs": [
						{
						  "internalType": "uint256",
						  "name": "",
						  "type": "uint256"
						}
					],
					"stateMutability": "view",
					"type": "function"
				}
			]
			
		</ts:abi>
	</ts:contract>
	<ts:contract name="DooarSwapRouter">
		<ts:address network="137">0xAcc8e414ceeCF0BBF438f6c4B7417Ca59dcF7E47</ts:address>
		<ts:abi>
			
				[{"inputs":[{"internalType":"address","name":"_factory","type":"address"},{"internalType":"address","name":"_WETH","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"WETH","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"tokenA","type":"address"},{"internalType":"address","name":"tokenB","type":"address"},{"internalType":"uint256","name":"amountADesired","type":"uint256"},{"internalType":"uint256","name":"amountBDesired","type":"uint256"},{"internalType":"uint256","name":"amountAMin","type":"uint256"},{"internalType":"uint256","name":"amountBMin","type":"uint256"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"addLiquidity","outputs":[{"internalType":"uint256","name":"amountA","type":"uint256"},{"internalType":"uint256","name":"amountB","type":"uint256"},{"internalType":"uint256","name":"liquidity","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"amountTokenDesired","type":"uint256"},{"internalType":"uint256","name":"amountTokenMin","type":"uint256"},{"internalType":"uint256","name":"amountETHMin","type":"uint256"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"addLiquidityETH","outputs":[{"internalType":"uint256","name":"amountToken","type":"uint256"},{"internalType":"uint256","name":"amountETH","type":"uint256"},{"internalType":"uint256","name":"liquidity","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"factory","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"},{"internalType":"uint256","name":"reserveIn","type":"uint256"},{"internalType":"uint256","name":"reserveOut","type":"uint256"}],"name":"getAmountIn","outputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"reserveIn","type":"uint256"},{"internalType":"uint256","name":"reserveOut","type":"uint256"}],"name":"getAmountOut","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"}],"name":"getAmountsIn","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"}],"name":"getAmountsOut","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountA","type":"uint256"},{"internalType":"uint256","name":"reserveA","type":"uint256"},{"internalType":"uint256","name":"reserveB","type":"uint256"}],"name":"quote","outputs":[{"internalType":"uint256","name":"amountB","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"address","name":"tokenA","type":"address"},{"internalType":"address","name":"tokenB","type":"address"},{"internalType":"uint256","name":"liquidity","type":"uint256"},{"internalType":"uint256","name":"amountAMin","type":"uint256"},{"internalType":"uint256","name":"amountBMin","type":"uint256"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"removeLiquidity","outputs":[{"internalType":"uint256","name":"amountA","type":"uint256"},{"internalType":"uint256","name":"amountB","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"liquidity","type":"uint256"},{"internalType":"uint256","name":"amountTokenMin","type":"uint256"},{"internalType":"uint256","name":"amountETHMin","type":"uint256"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"removeLiquidityETH","outputs":[{"internalType":"uint256","name":"amountToken","type":"uint256"},{"internalType":"uint256","name":"amountETH","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"liquidity","type":"uint256"},{"internalType":"uint256","name":"amountTokenMin","type":"uint256"},{"internalType":"uint256","name":"amountETHMin","type":"uint256"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"removeLiquidityETHSupportingFeeOnTransferTokens","outputs":[{"internalType":"uint256","name":"amountETH","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"liquidity","type":"uint256"},{"internalType":"uint256","name":"amountTokenMin","type":"uint256"},{"internalType":"uint256","name":"amountETHMin","type":"uint256"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bool","name":"approveMax","type":"bool"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"removeLiquidityETHWithPermit","outputs":[{"internalType":"uint256","name":"amountToken","type":"uint256"},{"internalType":"uint256","name":"amountETH","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"liquidity","type":"uint256"},{"internalType":"uint256","name":"amountTokenMin","type":"uint256"},{"internalType":"uint256","name":"amountETHMin","type":"uint256"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bool","name":"approveMax","type":"bool"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"removeLiquidityETHWithPermitSupportingFeeOnTransferTokens","outputs":[{"internalType":"uint256","name":"amountETH","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"tokenA","type":"address"},{"internalType":"address","name":"tokenB","type":"address"},{"internalType":"uint256","name":"liquidity","type":"uint256"},{"internalType":"uint256","name":"amountAMin","type":"uint256"},{"internalType":"uint256","name":"amountBMin","type":"uint256"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bool","name":"approveMax","type":"bool"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"removeLiquidityWithPermit","outputs":[{"internalType":"uint256","name":"amountA","type":"uint256"},{"internalType":"uint256","name":"amountB","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapETHForExactTokens","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactETHForTokens","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactETHForTokensSupportingFeeOnTransferTokens","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactTokensForETH","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactTokensForETHSupportingFeeOnTransferTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactTokensForTokens","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactTokensForTokensSupportingFeeOnTransferTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"},{"internalType":"uint256","name":"amountInMax","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapTokensForExactETH","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"},{"internalType":"uint256","name":"amountInMax","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapTokensForExactTokens","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"},{"stateMutability":"payable","type":"receive"}]
			
		</ts:abi>
	</ts:contract>
	<ts:origins>
		
		<ts:ethereum contract="Token"/>
	</ts:origins>

	<ts:style>
		
	
					
.ts-token-background {
    background-color: #444444;

}

.ts-token-container {
    background-color: #212121;
    color: #fff;
    border-radius: 25px;
}

.ts-token-container.popover-container {
    background-color: #444444 !important;
}

.ts-token-container * {
    color: #fff;
}

.ts-token-container .owner-count {
    color: #fff;
}

.btn {
    height: 40px;
    padding: 0 16px;
    border: none;
    border-radius: 10px;
    cursor: pointer;
}

.ts-card-button.btn-primary {
    background: linear-gradient(106.84deg, rgba(255, 140, 74, 0.9) 6.22%, rgba(255, 96, 95, 0.9) 90.19%) !important;
    border: none;
}

.ts-card-button.btn-primary:hover, .ts-card-button.btn-primary:disabled {
    background: linear-gradient(106.84deg, #FF8C4A 6.22%, #FF605F 90.19%) !important;
    border: none;
}

.ts-card-button.btn-primary:disabled {
    background: #4A4747 !important;
    border: none !important;
    pointer-events: none;
    cursor: not-allowed;
}

.ts-card-button.btn-primary span {
    color: white;
}

.ts-card-button.btn-secondary {
    border: 1px solid rgb(255, 88, 36);
    border-color: rgb(255, 88, 36) !important;
    background: transparent;
}

.ts-card-button.btn-secondary:disabled {
    border: 1px solid #5C5857 !important;
    background: #212121 !important;
    pointer-events: none;
    cursor: not-allowed;
}

.ts-card-button.btn-secondary span {
    background-image: linear-gradient(106.84deg, rgb(255, 140, 74) 6.22%, rgb(255, 96, 95) 90.19%);
    background-clip: text;
    color: transparent;
}

.ts-card-button.btn-secondary:disabled span {
    color: #83807F !important;
    background-image: unset !important;
}

.ts-card-button.btn-secondary:hover {
    border: 1px solid rgb(255, 88, 36);
    background: rgba(194, 140, 109, 0.06);
}

.ts-token-container .attribute-item {
    border: none;
    background-color: #292929;
}
					</ts:style>

	<ts:cards>
		<ts:viewContent xmlns="http://www.w3.org/1999/xhtml" name="common">
			
			
		<style>/*&lt;![CDATA[*/ 

.loader-container.svelte-i4cppe.svelte-i4cppe{width:100%;height:100%;display:flex;justify-content:center;align-items:center}.lds-ring.svelte-i4cppe.svelte-i4cppe{display:inline-block;position:relative;width:80px;height:80px}.lds-ring.svelte-i4cppe div.svelte-i4cppe{box-sizing:border-box;display:block;position:absolute;width:64px;height:64px;margin:8px;border:8px solid #656565;border-radius:50%;animation:svelte-i4cppe-lds-ring 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;border-color:#656565 transparent transparent transparent}.lds-ring.svelte-i4cppe div.svelte-i4cppe:nth-child(1){animation-delay:-0.45s}.lds-ring.svelte-i4cppe div.svelte-i4cppe:nth-child(2){animation-delay:-0.3s}.lds-ring.svelte-i4cppe div.svelte-i4cppe:nth-child(3){animation-delay:-0.15s}@keyframes svelte-i4cppe-lds-ring{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.image-icon.svelte-1inff93.svelte-1inff93{position:relative;border-radius:8px;overflow:hidden}.image-icon.svelte-1inff93 img.svelte-1inff93{border-radius:8px;width:100%}.shimmer.svelte-1inff93.svelte-1inff93{display:inline-block;background-color:#dddbdd;width:100%;height:100%}.shimmer.svelte-1inff93.svelte-1inff93:after{position:absolute;top:0;right:0;bottom:0;left:0;transform:translateX(-100%);background-image:linear-gradient(
			90deg,
			rgba(255, 255, 255, 0) 0,
			rgba(255, 255, 255, 0.2) 20%,
			rgba(255, 255, 255, 0.5) 60%,
			rgba(255, 255, 255, 0)
		);animation:svelte-1inff93-shimmer 2s infinite;content:""}@keyframes svelte-1inff93-shimmer{100%{transform:translateX(100%)}}.button-container.svelte-16rr0qr{display:flex;flex-wrap:wrap;gap:24px}.button-container .btn{flex:calc(50% - 16px)}.popover-modal.svelte-1hp8zpk.svelte-1hp8zpk{position:absolute;left:0;height:100%;width:100%;top:0;background-color:#00000082;align-items:center;justify-content:center;display:none;overflow:hidden;z-index:100}.popover-modal.open.svelte-1hp8zpk.svelte-1hp8zpk{display:flex !important;animation:svelte-1hp8zpk-fadeIn 0.25s}@keyframes svelte-1hp8zpk-fadeIn{0%{opacity:0}100%{opacity:1}}.popover-modal.open.svelte-1hp8zpk .popover-container.svelte-1hp8zpk{bottom:0 !important;animation:svelte-1hp8zpk-slideIn 0.25s}@keyframes svelte-1hp8zpk-slideIn{0%{transform:translateY(500px);animation-timing-function:ease-out}100%{transform:translateY(0px);animation-timing-function:ease-in}}.popover-container.svelte-1hp8zpk.svelte-1hp8zpk{box-sizing:border-box;position:absolute;height:fit-content;max-height:100%;width:100%;background:#212121;border-radius:8px;bottom:-100%;animation:svelte-1hp8zpk-slideIn 0.5s reverse;display:flex;flex-direction:column}.title-bar.svelte-1hp8zpk.svelte-1hp8zpk{display:flex;align-items:center;justify-content:center;color:#D4D3D3;margin:30px 0 0;padding-bottom:20px}.title.svelte-1hp8zpk.svelte-1hp8zpk{font-size:18px;margin:0 20px}.close-btn.svelte-1hp8zpk.svelte-1hp8zpk{position:absolute;z-index:100;left:24px;cursor:pointer}.close-btn.svelte-1hp8zpk span.svelte-1hp8zpk{font-weight:bold;line-height:24px;font-size:24px}.close-btn.svelte-1hp8zpk.svelte-1hp8zpk:hover{color:#cacaca}.popover-inner.svelte-1hp8zpk.svelte-1hp8zpk{position:relative;overflow:auto;display:flex;flex-direction:column;flex-grow:1;overflow-x:hidden;padding:0 15px 15px}@media(max-width: 500px){.popover-modal.svelte-1hp8zpk.svelte-1hp8zpk{align-items:end}.popover-container.svelte-1hp8zpk.svelte-1hp8zpk{border-radius:8px 8px 0 0 !important}}.attr-list.svelte-i29po.svelte-i29po{display:flex;flex-wrap:wrap;gap:16px}.attr-list.svelte-i29po .info-box.svelte-i29po{flex:calc(50% - 8px);max-width:calc(50% - 8px);display:flex;flex-direction:column}.row.svelte-i29po.svelte-i29po{margin:10px}.balance-row.svelte-1i3velq.svelte-1i3velq,hr.svelte-1i3velq.svelte-1i3velq{width:100%}hr.svelte-1i3velq.svelte-1i3velq{color:#46413F}.balance-row.svelte-1i3velq.svelte-1i3velq{display:flex;margin:10px 15px;align-items:center}.balance-row.svelte-1i3velq&gt;strong.svelte-1i3velq{display:flex;align-items:center;justify-content:flex-end}.balance-row.svelte-1i3velq img.svelte-1i3velq{margin-right:10px}.sut-icon.svelte-1i3velq.svelte-1i3velq{width:25px;height:auto;margin-right:5px}.burn-warning-text.svelte-1i3velq.svelte-1i3velq{color:#EF7676;font-size:14px}.balance-row.svelte-15o7gbg.svelte-15o7gbg{width:100%}.balance-row.svelte-15o7gbg.svelte-15o7gbg{display:flex;margin:10px 15px;align-items:center}.balance-row.svelte-15o7gbg img.svelte-15o7gbg{margin-right:10px}.sut-icon.svelte-15o7gbg.svelte-15o7gbg{width:35px;aspect-ratio:1/1;margin-right:5px}.confirm-box.svelte-15o7gbg span.svelte-15o7gbg:nth-child(1){color:#fff}.swap-panel.svelte-2n429h.svelte-2n429h{display:flex;gap:30px;padding:10px 0 0;align-items:flex-start}.token-header.svelte-2n429h.svelte-2n429h{display:flex;gap:10px;align-items:center;justify-content:center;padding:20px;margin:10px 0;background:rgba(31, 31, 31, 1);border-radius:8px}.token-icon.svelte-2n429h.svelte-2n429h{width:35px;height:auto}.swap-left.svelte-2n429h.svelte-2n429h,.swap-right.svelte-2n429h.svelte-2n429h{flex:50%;background:rgba(25, 25, 25, 1);border-radius:12px;padding:10px 30px;text-align:center}.arrow-box.svelte-2n429h.svelte-2n429h{position:absolute;width:80px;height:80px;border-radius:40px;left:calc(50% - 40px);top:125px;background:rgba(31, 31, 31, 1);border:6px solid rgba(25, 25, 25, 1);padding:10px}.amount-input.svelte-2n429h.svelte-2n429h{width:100%;height:60px;text-align:center;font-weight:bold;background:rgba(25, 25, 25, 1);font-size:32px;border:none !important}.amount-box.svelte-2n429h.svelte-2n429h{margin:30px 10px 10px}.balance-box.svelte-2n429h.svelte-2n429h{font-size:14px}.balance-box.svelte-2n429h .label.svelte-2n429h{color:rgba(175, 175, 175, 1)
	}.balance-box.svelte-2n429h .balance.svelte-2n429h{color:rgba(117, 117, 117, 1)}.slippage-header.svelte-2n429h.svelte-2n429h,.slippage-opts.svelte-2n429h.svelte-2n429h{display:flex;align-items:center;margin:5px 10px;gap:10px}.slippage-opts.svelte-2n429h button.svelte-2n429h{color:white;font-size:18px;background:rgba(12, 10, 10, 1);border:1px solid rgba(12, 10, 10, 1)}.slippage-opts.svelte-2n429h button.svelte-2n429h:hover{background:inherit;border:1px solid rgb(255, 88, 36) !important}.svelte-2n429h.svelte-2n429h:focus{outline:none}.svelte-2n429h.svelte-2n429h::-moz-focus-inner{border:0}.slippage-input.svelte-2n429h.svelte-2n429h{position:relative}.slippage-input.svelte-2n429h input.svelte-2n429h{width:100%;height:40px;padding:0 10px;font-size:18px}.slippage-input.svelte-2n429h input.svelte-2n429h:focus{border-color:rgb(255, 88, 36) !important}.slippage-input.svelte-2n429h strong.svelte-2n429h{position:absolute;right:10px;top:0;height:40px;font-size:18px;display:flex;align-items:center;justify-content:center}.close-btn.svelte-2n429h.svelte-2n429h{cursor:pointer}

 /*//]]&gt;*/</style>
<script type="module" crossorigin="">//&lt;![CDATA[

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) =&gt; key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) =&gt; {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList &amp;&amp; relList.supports &amp;&amp; relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) =&gt; {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" &amp;&amp; node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function noop() {
}
function assign$1(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T &amp; S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a &amp;&amp; typeof a === "object" || typeof a === "function";
}
let src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (element_src === url)
    return true;
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] &amp;&amp; fn ? assign$1($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] &amp;&amp; fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i &lt; len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length &gt; 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i &lt; length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k in props)
    if (!keys.has(k) &amp;&amp; k[0] !== "$")
      rest[k] = props[k];
  return rest;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function append(target, node) {
  target.appendChild(node);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data2) {
  return document.createTextNode(data2);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () =&gt; node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function set_svg_attributes(node, attributes) {
  for (const key in attributes) {
    attr(node, key, attributes[key]);
  }
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data2) {
  data2 = "" + data2;
  if (text2.data === data2)
    return;
  text2.data = /** @type {string} */
  data2;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
class HtmlTag {
  constructor(is_svg = false) {
    /**
     * @private
     * @default false
     */
    __publicField(this, "is_svg", false);
    /** parent for creating node */
    __publicField(this, "e");
    /** html tag nodes */
    __publicField(this, "n");
    /** target */
    __publicField(this, "t");
    /** anchor */
    __publicField(this, "a");
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(html) {
    this.h(html);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(
          /** @type {keyof SVGElementTagNameMap} */
          target.nodeName
        );
      else
        this.e = element(
          /** @type {keyof HTMLElementTagNameMap} */
          target.nodeType === 11 ? "TEMPLATE" : target.nodeName
        );
      this.t = target.tagName !== "TEMPLATE" ? target : (
        /** @type {HTMLTemplateElement} */
        target.content
      );
      this.c(html);
    }
    this.i(anchor);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(anchor) {
    for (let i = 0; i &lt; this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor);
    }
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(detach);
  }
}
function construct_svelte_component(component, props) {
  return new component(props);
}
let current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
const dirty_components = [];
const binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx &lt; dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i &lt; render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment &amp;&amp; $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) =&gt; fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) =&gt; c());
  render_callbacks = filtered;
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block &amp;&amp; block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block &amp;&amp; block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() =&gt; {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function create_component(block) {
  block &amp;&amp; block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment &amp;&amp; fragment.m(target, anchor);
  add_render_callback(() =&gt; {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment &amp;&amp; $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 &lt;&lt; i % 31;
}
function init(component, options, instance2, create_fragment2, not_equal, props, append_styles = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles &amp;&amp; append_styles($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i, ret, ...rest) =&gt; {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx &amp;&amp; not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound &amp;&amp; $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      const nodes = children(options.target);
      $$.fragment &amp;&amp; $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment &amp;&amp; $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    flush();
  }
  set_current_component(parent_component);
}
class SvelteComponent {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract&lt;keyof Events, string&gt;} K
   * @param {K} type
   * @param {((e: Events[K]) =&gt; void) | null | undefined} callback
   * @returns {() =&gt; void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () =&gt; {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial&lt;Props&gt;} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set &amp;&amp; !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
}
const PUBLIC_VERSION = "4";
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);
const subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i &lt; subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set, update2) || noop;
    }
    run2(value);
    return () =&gt; {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 &amp;&amp; stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe };
}
const ACTIVATION_URL = chainID != 137 ? "https://mooar-landing-page.vercel.app/" : "https://morchi.mooar.com/";
const ASSETS_URL = "https://resources.smartlayer.network/smart-token-store/tokenscripts/morchi/";
function getCharacterName(token) {
  var _a, _b, _c, _d;
  if ((_b = (_a = token.tokenInfo) == null ? void 0 : _a.attributes) == null ? void 0 : _b.length) {
    const character = (_d = (_c = token.tokenInfo) == null ? void 0 : _c.attributes) == null ? void 0 : _d.find((a) =&gt; a.trait_type === "Character");
    if (character)
      return character.value;
  }
  return "Morchi";
}
const data = writable({
  token: null
});
function setToken(token) {
  data.set({
    ...data,
    token
  });
}
const context = {
  data,
  setToken
};
const Loader_svelte_svelte_type_style_lang = "";
function create_if_block$9(ctx) {
  let div5;
  return {
    c() {
      div5 = element("div");
      div5.innerHTML = `&lt;div class="lds-ring svelte-i4cppe"&gt;&lt;div class="svelte-i4cppe"&gt;&lt;/div&gt; &lt;div class="svelte-i4cppe"&gt;&lt;/div&gt; &lt;div class="svelte-i4cppe"&gt;&lt;/div&gt; &lt;div class="svelte-i4cppe"&gt;&lt;/div&gt;&lt;/div&gt;`;
      attr(div5, "class", "loader-container svelte-i4cppe");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
    }
  };
}
function create_fragment$d(ctx) {
  let if_block_anchor;
  let if_block = (
    /*show*/
    ctx[0] &amp;&amp; create_if_block$9()
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*show*/
        ctx2[0]
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$9();
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$c($$self, $$props, $$invalidate) {
  let { show } = $$props;
  $$self.$$set = ($$props2) =&gt; {
    if ("show" in $$props2)
      $$invalidate(0, show = $$props2.show);
  };
  return [show];
}
class Loader extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$c, create_fragment$d, safe_not_equal, { show: 0 });
  }
}
const ImageIcon_svelte_svelte_type_style_lang = "";
function create_if_block$8(ctx) {
  let img;
  let img_src_value;
  let mounted;
  let dispose;
  return {
    c() {
      img = element("img");
      attr(img, "alt", "image");
      if (!src_url_equal(img.src, img_src_value = /*src*/
      ctx[0]))
        attr(img, "src", img_src_value);
      attr(img, "class", "svelte-1inff93");
    },
    m(target, anchor) {
      insert(target, img, anchor);
      if (!mounted) {
        dispose = listen(
          img,
          "load",
          /*load_handler*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty &amp; /*src*/
      1 &amp;&amp; !src_url_equal(img.src, img_src_value = /*src*/
      ctx2[0])) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$c(ctx) {
  let div1;
  let div0;
  let t;
  let div1_title_value;
  let if_block = (
    /*src*/
    ctx[0] &amp;&amp; create_if_block$8(ctx)
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "shimmer svelte-1inff93");
      set_style(
        div0,
        "display",
        /*loaded*/
        ctx[4] ? "none" : "block"
      );
      attr(div1, "class", "image-icon svelte-1inff93");
      set_style(
        div1,
        "width",
        /*width*/
        ctx[2]
      );
      set_style(
        div1,
        "height",
        /*width*/
        ctx[2]
      );
      set_style(
        div1,
        "max-width",
        /*maxWidth*/
        ctx[3]
      );
      set_style(div1, "margin", "0 auto");
      attr(div1, "title", div1_title_value = /*title*/
      ctx[1] ?? "");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div1, t);
      if (if_block)
        if_block.m(div1, null);
    },
    p(ctx2, [dirty]) {
      if (dirty &amp; /*loaded*/
      16) {
        set_style(
          div0,
          "display",
          /*loaded*/
          ctx2[4] ? "none" : "block"
        );
      }
      if (
        /*src*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$8(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty &amp; /*width*/
      4) {
        set_style(
          div1,
          "width",
          /*width*/
          ctx2[2]
        );
      }
      if (dirty &amp; /*width*/
      4) {
        set_style(
          div1,
          "height",
          /*width*/
          ctx2[2]
        );
      }
      if (dirty &amp; /*maxWidth*/
      8) {
        set_style(
          div1,
          "max-width",
          /*maxWidth*/
          ctx2[3]
        );
      }
      if (dirty &amp; /*title*/
      2 &amp;&amp; div1_title_value !== (div1_title_value = /*title*/
      ctx2[1] ?? "")) {
        attr(div1, "title", div1_title_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance$b($$self, $$props, $$invalidate) {
  let { src } = $$props;
  let { title } = $$props;
  let { width = "40px" } = $$props;
  let { maxWidth = "none" } = $$props;
  let loaded = false;
  const load_handler = () =&gt; $$invalidate(4, loaded = true);
  $$self.$$set = ($$props2) =&gt; {
    if ("src" in $$props2)
      $$invalidate(0, src = $$props2.src);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("maxWidth" in $$props2)
      $$invalidate(3, maxWidth = $$props2.maxWidth);
  };
  return [src, title, width, maxWidth, loaded, load_handler];
}
class ImageIcon extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$b, create_fragment$c, safe_not_equal, { src: 0, title: 1, width: 2, maxWidth: 3 });
  }
}
const ActionButtons_svelte_svelte_type_style_lang = "";
function create_fragment$b(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "row button-container svelte-16rr0qr");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p &amp;&amp; (!current || dirty &amp; /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) =&gt; {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class ActionButtons extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$a, create_fragment$b, safe_not_equal, {});
  }
}
const PopoverModal_svelte_svelte_type_style_lang = "";
function create_if_block$7(ctx) {
  let div;
  let h2;
  let t0;
  let t1;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      h2 = element("h2");
      t0 = text(
        /*title*/
        ctx[0]
      );
      t1 = space();
      button = element("button");
      button.innerHTML = `&lt;span class="svelte-1hp8zpk"&gt;&amp;lt;&lt;/span&gt;`;
      attr(h2, "class", "title svelte-1hp8zpk");
      attr(button, "class", "close-btn btn btn-secondary svelte-1hp8zpk");
      attr(div, "class", "title-bar svelte-1hp8zpk");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, h2);
      append(h2, t0);
      append(div, t1);
      append(div, button);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty &amp; /*title*/
      1)
        set_data(
          t0,
          /*title*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$a(ctx) {
  let div2;
  let div1;
  let t;
  let div0;
  let current;
  let mounted;
  let dispose;
  let if_block = !/*hideTitleBar*/
  ctx[1] &amp;&amp; create_if_block$7(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "popover-inner svelte-1hp8zpk");
      attr(div1, "class", "popover-container svelte-1hp8zpk");
      attr(div2, "class", null_to_empty("popover-modal " + /*id*/
      ctx[2] + (open ? " open" : "")) + " svelte-1hp8zpk");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      if (if_block)
        if_block.m(div1, null);
      append(div1, t);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          div2,
          "click",
          /*click_handler_1*/
          ctx[8]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!/*hideTitleBar*/
      ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$7(ctx2);
          if_block.c();
          if_block.m(div1, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p &amp;&amp; (!current || dirty &amp; /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { dismissCallback = null } = $$props;
  let { title = null } = $$props;
  let { hideTitleBar = false } = $$props;
  const id = Date.now();
  function dismiss() {
    if (dismissCallback) {
      dismissCallback();
      $$invalidate(4, dismissCallback = null);
    }
  }
  const click_handler = () =&gt; dismiss();
  const click_handler_1 = (e) =&gt; {
    if (e.target.classList.contains(id))
      dismiss();
  };
  $$self.$$set = ($$props2) =&gt; {
    if ("dismissCallback" in $$props2)
      $$invalidate(4, dismissCallback = $$props2.dismissCallback);
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("hideTitleBar" in $$props2)
      $$invalidate(1, hideTitleBar = $$props2.hideTitleBar);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [
    title,
    hideTitleBar,
    id,
    dismiss,
    dismissCallback,
    $$scope,
    slots,
    click_handler,
    click_handler_1
  ];
}
class PopoverModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$9, create_fragment$a, safe_not_equal, {
      dismissCallback: 4,
      title: 0,
      hideTitleBar: 1
    });
  }
}
const SUTIcon = "data:image/png;base64,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";
const BioCard_svelte_svelte_type_style_lang = "";
function create_if_block$6(ctx) {
  let actionbuttons;
  let current;
  actionbuttons = new ActionButtons({
    props: {
      $$slots: { default: [create_default_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(actionbuttons.$$.fragment);
    },
    m(target, anchor) {
      mount_component(actionbuttons, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const actionbuttons_changes = {};
      if (dirty &amp; /*$$scope, token, openRedeem, openLevelUp*/
      519) {
        actionbuttons_changes.$$scope = { dirty, ctx: ctx2 };
      }
      actionbuttons.$set(actionbuttons_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(actionbuttons.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actionbuttons.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(actionbuttons, detaching);
    }
  };
}
function create_if_block_2$2(ctx) {
  let div;
  let button;
  let span;
  let t0_value = (
    /*token*/
    ctx[0].morchiInfo.state.level == 29 ? "Final Upgrade" : "Level Up"
  );
  let t0;
  let button_disabled_value;
  let t1;
  let small;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      small = element("small");
      small.textContent = `Daily tasks ${/*tasksCompleted*/
      ctx[4]}/3 finished`;
      attr(button, "class", "btn btn-primary");
      set_style(button, "width", "100%");
      button.disabled = button_disabled_value = !/*token*/
      ctx[0].morchiInfo.canLevelUp;
      attr(small, "class", "task-hint-text");
      set_style(div, "flex", "100%");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, span);
      append(span, t0);
      append(div, t1);
      append(div, small);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty &amp; /*token*/
      1 &amp;&amp; t0_value !== (t0_value = /*token*/
      ctx2[0].morchiInfo.state.level == 29 ? "Final Upgrade" : "Level Up"))
        set_data(t0, t0_value);
      if (dirty &amp; /*token*/
      1 &amp;&amp; button_disabled_value !== (button_disabled_value = !/*token*/
      ctx2[0].morchiInfo.canLevelUp)) {
        button.disabled = button_disabled_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$3(ctx) {
  let small;
  return {
    c() {
      small = element("small");
      small.textContent = "Unlock after level 20";
      attr(small, "class", "task-hint-text");
    },
    m(target, anchor) {
      insert(target, small, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(small);
      }
    }
  };
}
function create_default_slot$2(ctx) {
  let t0;
  let div;
  let button0;
  let span0;
  let button0_disabled_value;
  let t2;
  let button1;
  let t4;
  let mounted;
  let dispose;
  let if_block0 = (
    /*token*/
    ctx[0].morchiInfo.state.level &lt; 30 &amp;&amp; create_if_block_2$2(ctx)
  );
  let if_block1 = (
    /*token*/
    ctx[0].morchiInfo.state.level &lt; 20n &amp;&amp; create_if_block_1$3()
  );
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      div = element("div");
      button0 = element("button");
      span0 = element("span");
      span0.textContent = "Redeem Tokens";
      t2 = space();
      button1 = element("button");
      button1.innerHTML = `&lt;span&gt;Add Token&lt;/span&gt;`;
      t4 = space();
      if (if_block1)
        if_block1.c();
      attr(button0, "class", "btn btn-secondary");
      button0.disabled = button0_disabled_value = /*token*/
      ctx[0].morchiInfo.state.level &lt; 20n;
      attr(button1, "class", "btn btn-secondary");
      set_style(div, "flex", "100%");
      set_style(div, "display", "flex");
      set_style(div, "column-gap", "24px");
      set_style(div, "flex-wrap", "wrap");
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      append(div, button0);
      append(button0, span0);
      append(div, t2);
      append(div, button1);
      append(div, t4);
      if (if_block1)
        if_block1.m(div, null);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler_1*/
            ctx[7]
          ),
          listen(
            button1,
            "click",
            /*click_handler_2*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*token*/
        ctx2[0].morchiInfo.state.level &lt; 30
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$2(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty &amp; /*token*/
      1 &amp;&amp; button0_disabled_value !== (button0_disabled_value = /*token*/
      ctx2[0].morchiInfo.state.level &lt; 20n)) {
        button0.disabled = button0_disabled_value;
      }
      if (
        /*token*/
        ctx2[0].morchiInfo.state.level &lt; 20n
      ) {
        if (if_block1)
          ;
        else {
          if_block1 = create_if_block_1$3();
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$9(ctx) {
  var _a;
  let div0;
  let imageicon;
  let t0;
  let div5;
  let div1;
  let span;
  let strong0;
  let t2_value = Number(ethers.formatEther(
    /*token*/
    ctx[0].morchiInfo.state.pointsBalance
  )).toFixed(2) + "";
  let t2;
  let t3;
  let div4;
  let div2;
  let small0;
  let t5;
  let strong1;
  let t6_value = (
    /*token*/
    ctx[0].morchiInfo.state.level + ""
  );
  let t6;
  let t7;
  let div3;
  let small1;
  let t9;
  let strong2;
  let t10_value = (
    /*token*/
    (((_a = ctx[0].tokenInfo.attributes.find(func)) == null ? void 0 : _a.value) ?? "-") + ""
  );
  let t10;
  let t11;
  let if_block_anchor;
  let current;
  imageicon = new ImageIcon({
    props: {
      src: (
        /*token*/
        ctx[0].image_preview_url
      ),
      width: "100%"
    }
  });
  let if_block = !/*isPublic*/
  ctx[3] &amp;&amp; create_if_block$6(ctx);
  return {
    c() {
      div0 = element("div");
      create_component(imageicon.$$.fragment);
      t0 = space();
      div5 = element("div");
      div1 = element("div");
      span = element("span");
      span.textContent = "Points";
      strong0 = element("strong");
      t2 = text(t2_value);
      t3 = space();
      div4 = element("div");
      div2 = element("div");
      small0 = element("small");
      small0.textContent = "Level";
      t5 = space();
      strong1 = element("strong");
      t6 = text(t6_value);
      t7 = space();
      div3 = element("div");
      small1 = element("small");
      small1.textContent = "Rarity";
      t9 = space();
      strong2 = element("strong");
      t10 = text(t10_value);
      t11 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(div0, "class", "row svelte-i29po");
      set_style(strong0, "flex-grow", "1");
      set_style(strong0, "text-align", "right");
      attr(div1, "class", "info-box");
      set_style(div1, "display", "flex");
      attr(div2, "class", "info-box svelte-i29po");
      attr(div3, "class", "info-box svelte-i29po");
      attr(div4, "class", "attr-list svelte-i29po");
      set_style(div4, "margin-top", "16px");
      attr(div5, "class", "row svelte-i29po");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      mount_component(imageicon, div0, null);
      insert(target, t0, anchor);
      insert(target, div5, anchor);
      append(div5, div1);
      append(div1, span);
      append(div1, strong0);
      append(strong0, t2);
      append(div5, t3);
      append(div5, div4);
      append(div4, div2);
      append(div2, small0);
      append(div2, t5);
      append(div2, strong1);
      append(strong1, t6);
      append(div4, t7);
      append(div4, div3);
      append(div3, small1);
      append(div3, t9);
      append(div3, strong2);
      append(strong2, t10);
      insert(target, t11, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2;
      const imageicon_changes = {};
      if (dirty &amp; /*token*/
      1)
        imageicon_changes.src = /*token*/
        ctx2[0].image_preview_url;
      imageicon.$set(imageicon_changes);
      if ((!current || dirty &amp; /*token*/
      1) &amp;&amp; t2_value !== (t2_value = Number(ethers.formatEther(
        /*token*/
        ctx2[0].morchiInfo.state.pointsBalance
      )).toFixed(2) + ""))
        set_data(t2, t2_value);
      if ((!current || dirty &amp; /*token*/
      1) &amp;&amp; t6_value !== (t6_value = /*token*/
      ctx2[0].morchiInfo.state.level + ""))
        set_data(t6, t6_value);
      if ((!current || dirty &amp; /*token*/
      1) &amp;&amp; t10_value !== (t10_value = /*token*/
      (((_a2 = ctx2[0].tokenInfo.attributes.find(func)) == null ? void 0 : _a2.value) ?? "-") + ""))
        set_data(t10, t10_value);
      if (!/*isPublic*/
      ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty &amp; /*isPublic*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () =&gt; {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(imageicon.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(imageicon.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t0);
        detach(div5);
        detach(t11);
        detach(if_block_anchor);
      }
      destroy_component(imageicon);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
const func = (a) =&gt; a.trait_type === "Rarity";
function instance$8($$self, $$props, $$invalidate) {
  let { token } = $$props;
  let { openLevelUp } = $$props;
  let { openRedeem } = $$props;
  let { isPublic = false } = $$props;
  let tasksCompleted = (token.morchiInfo.state.hasWorkedOut ? 1 : 0) + (token.morchiInfo.state.hasShowered ? 1 : 0) + (token.morchiInfo.state.hasDrunk ? 1 : 0);
  async function addSUTToken() {
    try {
      tokenscript.action.showLoader();
      const provider = new ethers.BrowserProvider(window.ethereum, ethers.Network.from(token.chainId));
      await provider.send("wallet_watchAsset", {
        "type": "ERC20",
        "options": {
          "address": tokenscript.eth.getContractInfo("SUTToken").address,
          "symbol": "SUT",
          "decimals": 18,
          "image": SUTIcon
        }
      });
    } catch (e) {
      console.error(e);
      tokenscript.action.showMessageToast("error", "Could not add SUT", "Could not add SUT in the connected wallet, please add manually");
    }
    tokenscript.action.hideLoader();
  }
  const click_handler = () =&gt; openLevelUp();
  const click_handler_1 = () =&gt; openRedeem();
  const click_handler_2 = () =&gt; addSUTToken();
  $$self.$$set = ($$props2) =&gt; {
    if ("token" in $$props2)
      $$invalidate(0, token = $$props2.token);
    if ("openLevelUp" in $$props2)
      $$invalidate(1, openLevelUp = $$props2.openLevelUp);
    if ("openRedeem" in $$props2)
      $$invalidate(2, openRedeem = $$props2.openRedeem);
    if ("isPublic" in $$props2)
      $$invalidate(3, isPublic = $$props2.isPublic);
  };
  return [
    token,
    openLevelUp,
    openRedeem,
    isPublic,
    tasksCompleted,
    addSUTToken,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
class BioCard extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$8, create_fragment$9, safe_not_equal, {
      token: 0,
      openLevelUp: 1,
      openRedeem: 2,
      isPublic: 3
    });
  }
}
function create_if_block$5(ctx) {
  let title_1;
  let t;
  return {
    c() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert(target, title_1, anchor);
      append(title_1, t);
    },
    p(ctx2, dirty) {
      if (dirty &amp; /*title*/
      32)
        set_data(
          t,
          /*title*/
          ctx2[5]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(title_1);
      }
    }
  };
}
function create_fragment$8(ctx) {
  let svg;
  let if_block_anchor;
  let html_tag;
  let if_block = (
    /*title*/
    ctx[5] &amp;&amp; create_if_block$5(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { width: (
      /*width*/
      ctx[1]
    ) },
    { height: (
      /*height*/
      ctx[2]
    ) },
    { viewBox: (
      /*viewBox*/
      ctx[0]
    ) },
    { stroke: (
      /*stroke*/
      ctx[3]
    ) },
    { fill: (
      /*fill*/
      ctx[4]
    ) },
    /*$$restProps*/
    ctx[7]
  ];
  let svg_data = {};
  for (let i = 0; i &lt; svg_levels.length; i += 1) {
    svg_data = assign$1(svg_data, svg_levels[i]);
  }
  return {
    c() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      html_tag = new HtmlTag(true);
      html_tag.a = null;
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append(svg, if_block_anchor);
      html_tag.m(
        /*elements*/
        ctx[6],
        svg
      );
    },
    p(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[5]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$5(ctx2);
          if_block.c();
          if_block.m(svg, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty &amp; /*elements*/
      64)
        html_tag.p(
          /*elements*/
          ctx2[6]
        );
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        dirty &amp; /*width*/
        2 &amp;&amp; { width: (
          /*width*/
          ctx2[1]
        ) },
        dirty &amp; /*height*/
        4 &amp;&amp; { height: (
          /*height*/
          ctx2[2]
        ) },
        dirty &amp; /*viewBox*/
        1 &amp;&amp; { viewBox: (
          /*viewBox*/
          ctx2[0]
        ) },
        dirty &amp; /*stroke*/
        8 &amp;&amp; { stroke: (
          /*stroke*/
          ctx2[3]
        ) },
        dirty &amp; /*fill*/
        16 &amp;&amp; { fill: (
          /*fill*/
          ctx2[4]
        ) },
        dirty &amp; /*$$restProps*/
        128 &amp;&amp; /*$$restProps*/
        ctx2[7]
      ]));
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function extractViewBox(svg) {
  const regex = /viewBox="([\d\- \.]+)"/;
  const res = regex.exec(svg);
  if (!res)
    return "0 0 20 20";
  return res[1];
}
function instance$7($$self, $$props, $$invalidate) {
  let elements;
  const omit_props_names = ["data", "viewBox", "size", "width", "height", "color", "stroke", "fill", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { data: data2 = "" } = $$props;
  let { viewBox = extractViewBox(data2) } = $$props;
  let { size = "20px" } = $$props;
  let { width = size } = $$props;
  let { height = size } = $$props;
  let { color = "currentColor" } = $$props;
  let { stroke = color } = $$props;
  let { fill = color } = $$props;
  let { title = "" } = $$props;
  $$self.$$set = ($$new_props) =&gt; {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("data" in $$new_props)
      $$invalidate(8, data2 = $$new_props.data);
    if ("viewBox" in $$new_props)
      $$invalidate(0, viewBox = $$new_props.viewBox);
    if ("size" in $$new_props)
      $$invalidate(9, size = $$new_props.size);
    if ("width" in $$new_props)
      $$invalidate(1, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(2, height = $$new_props.height);
    if ("color" in $$new_props)
      $$invalidate(10, color = $$new_props.color);
    if ("stroke" in $$new_props)
      $$invalidate(3, stroke = $$new_props.stroke);
    if ("fill" in $$new_props)
      $$invalidate(4, fill = $$new_props.fill);
    if ("title" in $$new_props)
      $$invalidate(5, title = $$new_props.title);
  };
  $$self.$$.update = () =&gt; {
    if ($$self.$$.dirty &amp; /*data*/
    256) {
      $$invalidate(6, elements = data2.replace(/&lt;svg[ \n]([^&gt;]*)&gt;/, "").replace("&lt;/svg&gt;", ""));
    }
  };
  return [
    viewBox,
    width,
    height,
    stroke,
    fill,
    title,
    elements,
    $$restProps,
    data2,
    size,
    color
  ];
}
class Icon extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$7, create_fragment$8, safe_not_equal, {
      data: 8,
      viewBox: 0,
      size: 9,
      width: 1,
      height: 2,
      color: 10,
      stroke: 3,
      fill: 4,
      title: 5
    });
  }
}
const ArrowSvg$1 = '&lt;svg width="101" height="16" viewBox="0 0 101 16" fill="none" xmlns="http://www.w3.org/2000/svg"&gt;\n&lt;path d="M100.707 8.70711C101.098 8.31658 101.098 7.68342 100.707 7.29289L94.3431 0.928932C93.9526 0.538408 93.3195 0.538408 92.9289 0.928932C92.5384 1.31946 92.5384 1.95262 92.9289 2.34315L98.5858 8L92.9289 13.6569C92.5384 14.0474 92.5384 14.6805 92.9289 15.0711C93.3195 15.4616 93.9526 15.4616 94.3431 15.0711L100.707 8.70711ZM0 9H100V7H0V9Z" fill="url(#paint0_linear_32_1888)"/&gt;\n&lt;defs&gt;\n&lt;linearGradient id="paint0_linear_32_1888" x1="-4.08163" y1="8.4026" x2="-3.96241" y2="12.0119" gradientUnits="userSpaceOnUse"&gt;\n&lt;stop stop-color="#FF8C4A"/&gt;\n&lt;stop offset="1" stop-color="#FF605F"/&gt;\n&lt;/linearGradient&gt;\n&lt;/defs&gt;\n&lt;/svg&gt;\n';
const ArrowShortSvg = '&lt;svg width="32" height="16" viewBox="0 0 32 16" fill="none" xmlns="http://www.w3.org/2000/svg"&gt;\n&lt;path d="M31.7071 8.70711C32.0976 8.31658 32.0976 7.68342 31.7071 7.29289L25.3431 0.928932C24.9526 0.538408 24.3195 0.538408 23.9289 0.928932C23.5384 1.31946 23.5384 1.95262 23.9289 2.34315L29.5858 8L23.9289 13.6569C23.5384 14.0474 23.5384 14.6805 23.9289 15.0711C24.3195 15.4616 24.9526 15.4616 25.3431 15.0711L31.7071 8.70711ZM0 9H31V7H0V9Z" fill="url(#paint0_linear_959_589)"/&gt;\n&lt;defs&gt;\n&lt;linearGradient id="paint0_linear_959_589" x1="-1.2653" y1="8.4026" x2="-0.884631" y2="11.9753" gradientUnits="userSpaceOnUse"&gt;\n&lt;stop stop-color="#FF8C4A"/&gt;\n&lt;stop offset="1" stop-color="#FF605F"/&gt;\n&lt;/linearGradient&gt;\n&lt;/defs&gt;\n&lt;/svg&gt;\n';
const LevelUpCard_svelte_svelte_type_style_lang = "";
function create_else_block$2(ctx) {
  let div2;
  let div0;
  let h20;
  let t0;
  let t1_value = (
    /*token*/
    ctx[0].morchiInfo.state.level + ""
  );
  let t1;
  let t2;
  let icon;
  let t3;
  let h21;
  let t4_value = (
    /*token*/
    ctx[0].morchiInfo.state.level == 29 ? "3 MORCHI Achievement NFTs" : "Lv. " + (BigInt(
      /*token*/
      ctx[0].morchiInfo.state.level
    ) + 1n)
  );
  let t4;
  let t5;
  let t6;
  let hr0;
  let t7;
  let div1;
  let span0;
  let t9;
  let strong0;
  let img0;
  let img0_src_value;
  let t10;
  let t11_value = (
    /*levelUpCost*/
    (ctx[4] !== null ? Number(ethers.formatEther(
      /*levelUpCost*/
      ctx[4]
    )).toFixed(2) : "-") + ""
  );
  let t11;
  let t12;
  let div7;
  let div3;
  let span1;
  let t14;
  let strong1;
  let img1;
  let img1_src_value;
  let t15;
  let t16_value = Number(ethers.formatEther(BigInt(
    /*token*/
    ctx[0].morchiInfo.state.pointsBalance
  ) + /*balance*/
  (ctx[2] !== null ? (
    /*balance*/
    ctx[2]
  ) : 0n))).toFixed(2) + "";
  let t16;
  let t17;
  let hr1;
  let t18;
  let div6;
  let div4;
  let span2;
  let strong2;
  let t20_value = Number(ethers.formatEther(
    /*token*/
    ctx[0].morchiInfo.state.pointsBalance
  )).toFixed(2) + "";
  let t20;
  let t21;
  let div5;
  let span3;
  let strong3;
  let t23_value = (
    /*balance*/
    (ctx[2] !== null ? Number(ethers.formatEther(
      /*balance*/
      ctx[2]
    )).toFixed(2) : "-") + ""
  );
  let t23;
  let t24;
  let t25;
  let div8;
  let button0;
  let t27;
  let button1;
  let span5;
  let t28_value = (
    /*token*/
    ctx[0].morchiInfo.state.level == 29 ? "Burn MORCHI &amp; Upgrade" : "Level Up"
  );
  let t28;
  let button1_disabled_value;
  let t29;
  let if_block2_anchor;
  let current;
  let mounted;
  let dispose;
  icon = new Icon({
    props: {
      data: (
        /*token*/
        ctx[0].morchiInfo.state.level == 29 ? ArrowShortSvg : ArrowSvg$1
      ),
      width: (
        /*token*/
        ctx[0].morchiInfo.state.level == 29 ? "32px" : "120px"
      ),
      stroke: "unset"
    }
  });
  function select_block_type_1(ctx2, dirty) {
    if (
      /*token*/
      ctx2[0].morchiInfo.state.level == 9
    )
      return create_if_block_3$1;
    if (
      /*token*/
      ctx2[0].morchiInfo.state.level == 29
    )
      return create_if_block_4$1;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block0 = current_block_type &amp;&amp; current_block_type(ctx);
  let if_block1 = (
    /*balance*/
    ctx[2] !== null &amp;&amp; /*levelUpCost*/
    ctx[4] !== null &amp;&amp; /*balance*/
    ctx[2] + /*pointsBalance*/
    ctx[3] &lt; /*levelUpCost*/
    ctx[4] &amp;&amp; create_if_block_2$1()
  );
  let if_block2 = (
    /*token*/
    ctx[0].morchiInfo.state.level == 29 &amp;&amp; create_if_block_1$2()
  );
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      h20 = element("h2");
      t0 = text("Lv. ");
      t1 = text(t1_value);
      t2 = space();
      create_component(icon.$$.fragment);
      t3 = space();
      h21 = element("h2");
      t4 = text(t4_value);
      t5 = space();
      if (if_block0)
        if_block0.c();
      t6 = space();
      hr0 = element("hr");
      t7 = space();
      div1 = element("div");
      span0 = element("span");
      span0.textContent = "Total Price";
      t9 = space();
      strong0 = element("strong");
      img0 = element("img");
      t10 = space();
      t11 = text(t11_value);
      t12 = space();
      div7 = element("div");
      div3 = element("div");
      span1 = element("span");
      span1.textContent = "Your Balance";
      t14 = space();
      strong1 = element("strong");
      img1 = element("img");
      t15 = space();
      t16 = text(t16_value);
      t17 = space();
      hr1 = element("hr");
      t18 = space();
      div6 = element("div");
      div4 = element("div");
      span2 = element("span");
      span2.textContent = "Your Points ";
      strong2 = element("strong");
      t20 = text(t20_value);
      t21 = space();
      div5 = element("div");
      span3 = element("span");
      span3.textContent = "Your Tokens ";
      strong3 = element("strong");
      t23 = text(t23_value);
      t24 = space();
      if (if_block1)
        if_block1.c();
      t25 = space();
      div8 = element("div");
      button0 = element("button");
      button0.innerHTML = `&lt;span&gt;Add funds&lt;/span&gt;`;
      t27 = space();
      button1 = element("button");
      span5 = element("span");
      t28 = text(t28_value);
      t29 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      set_style(div0, "display", "flex");
      set_style(div0, "align-items", "center");
      set_style(div0, "gap", "15px");
      attr(hr0, "class", "svelte-1i3velq");
      attr(img0, "class", "sut-icon svelte-1i3velq");
      attr(img0, "alt", "SUT");
      if (!src_url_equal(img0.src, img0_src_value = SUTIcon))
        attr(img0, "src", img0_src_value);
      set_style(strong0, "flex-grow", "1");
      set_style(strong0, "text-align", "right");
      attr(strong0, "class", "svelte-1i3velq");
      attr(div1, "class", "balance-row svelte-1i3velq");
      attr(div2, "class", "row info-box");
      set_style(div2, "display", "flex");
      set_style(div2, "flex-direction", "column");
      attr(img1, "class", "sut-icon svelte-1i3velq");
      attr(img1, "alt", "SUT");
      if (!src_url_equal(img1.src, img1_src_value = SUTIcon))
        attr(img1, "src", img1_src_value);
      set_style(strong1, "flex-grow", "1");
      set_style(strong1, "text-align", "right");
      attr(strong1, "class", "svelte-1i3velq");
      attr(div3, "class", "balance-row svelte-1i3velq");
      attr(hr1, "class", "svelte-1i3velq");
      set_style(strong2, "text-align", "right");
      set_style(div4, "flex-grow", "1");
      set_style(strong3, "text-align", "right");
      set_style(div5, "flex-grow", "1");
      set_style(div5, "text-align", "right");
      attr(div6, "class", "balance-row svelte-1i3velq");
      attr(div7, "class", "row info-box");
      set_style(div7, "display", "flex");
      set_style(div7, "flex-direction", "column");
      attr(button0, "class", "btn btn-secondary");
      set_style(button0, "width", "100%");
      attr(button1, "class", "btn btn-primary");
      set_style(button1, "width", "100%");
      button1.disabled = button1_disabled_value = !/*token*/
      ctx[0].morchiInfo.canLevelUp || /*balance*/
      ctx[2] === null || /*levelUpCost*/
      ctx[4] === null || /*balance*/
      ctx[2] + /*pointsBalance*/
      ctx[3] &lt; /*levelUpCost*/
      ctx[4];
      attr(div8, "class", "row");
      set_style(div8, "display", "flex");
      set_style(div8, "flex-direction", "column");
      set_style(div8, "gap", "20px");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, h20);
      append(h20, t0);
      append(h20, t1);
      append(div0, t2);
      mount_component(icon, div0, null);
      append(div0, t3);
      append(div0, h21);
      append(h21, t4);
      append(div2, t5);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t6);
      append(div2, hr0);
      append(div2, t7);
      append(div2, div1);
      append(div1, span0);
      append(div1, t9);
      append(div1, strong0);
      append(strong0, img0);
      append(strong0, t10);
      append(strong0, t11);
      insert(target, t12, anchor);
      insert(target, div7, anchor);
      append(div7, div3);
      append(div3, span1);
      append(div3, t14);
      append(div3, strong1);
      append(strong1, img1);
      append(strong1, t15);
      append(strong1, t16);
      append(div7, t17);
      append(div7, hr1);
      append(div7, t18);
      append(div7, div6);
      append(div6, div4);
      append(div4, span2);
      append(div4, strong2);
      append(strong2, t20);
      append(div6, t21);
      append(div6, div5);
      append(div5, span3);
      append(div5, strong3);
      append(strong3, t23);
      insert(target, t24, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t25, anchor);
      insert(target, div8, anchor);
      append(div8, button0);
      append(div8, t27);
      append(div8, button1);
      append(button1, span5);
      append(span5, t28);
      insert(target, t29, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler_2*/
            ctx[12]
          ),
          listen(
            button1,
            "click",
            /*click_handler_3*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty &amp; /*token*/
      1) &amp;&amp; t1_value !== (t1_value = /*token*/
      ctx2[0].morchiInfo.state.level + ""))
        set_data(t1, t1_value);
      const icon_changes = {};
      if (dirty &amp; /*token*/
      1)
        icon_changes.data = /*token*/
        ctx2[0].morchiInfo.state.level == 29 ? ArrowShortSvg : ArrowSvg$1;
      if (dirty &amp; /*token*/
      1)
        icon_changes.width = /*token*/
        ctx2[0].morchiInfo.state.level == 29 ? "32px" : "120px";
      icon.$set(icon_changes);
      if ((!current || dirty &amp; /*token*/
      1) &amp;&amp; t4_value !== (t4_value = /*token*/
      ctx2[0].morchiInfo.state.level == 29 ? "3 MORCHI Achievement NFTs" : "Lv. " + (BigInt(
        /*token*/
        ctx2[0].morchiInfo.state.level
      ) + 1n)))
        set_data(t4, t4_value);
      if (current_block_type !== (current_block_type = select_block_type_1(ctx2))) {
        if (if_block0)
          if_block0.d(1);
        if_block0 = current_block_type &amp;&amp; current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div2, t6);
        }
      }
      if ((!current || dirty &amp; /*levelUpCost*/
      16) &amp;&amp; t11_value !== (t11_value = /*levelUpCost*/
      (ctx2[4] !== null ? Number(ethers.formatEther(
        /*levelUpCost*/
        ctx2[4]
      )).toFixed(2) : "-") + ""))
        set_data(t11, t11_value);
      if ((!current || dirty &amp; /*token, balance*/
      5) &amp;&amp; t16_value !== (t16_value = Number(ethers.formatEther(BigInt(
        /*token*/
        ctx2[0].morchiInfo.state.pointsBalance
      ) + /*balance*/
      (ctx2[2] !== null ? (
        /*balance*/
        ctx2[2]
      ) : 0n))).toFixed(2) + ""))
        set_data(t16, t16_value);
      if ((!current || dirty &amp; /*token*/
      1) &amp;&amp; t20_value !== (t20_value = Number(ethers.formatEther(
        /*token*/
        ctx2[0].morchiInfo.state.pointsBalance
      )).toFixed(2) + ""))
        set_data(t20, t20_value);
      if ((!current || dirty &amp; /*balance*/
      4) &amp;&amp; t23_value !== (t23_value = /*balance*/
      (ctx2[2] !== null ? Number(ethers.formatEther(
        /*balance*/
        ctx2[2]
      )).toFixed(2) : "-") + ""))
        set_data(t23, t23_value);
      if (
        /*balance*/
        ctx2[2] !== null &amp;&amp; /*levelUpCost*/
        ctx2[4] !== null &amp;&amp; /*balance*/
        ctx2[2] + /*pointsBalance*/
        ctx2[3] &lt; /*levelUpCost*/
        ctx2[4]
      ) {
        if (if_block1)
          ;
        else {
          if_block1 = create_if_block_2$1();
          if_block1.c();
          if_block1.m(t25.parentNode, t25);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if ((!current || dirty &amp; /*token*/
      1) &amp;&amp; t28_value !== (t28_value = /*token*/
      ctx2[0].morchiInfo.state.level == 29 ? "Burn MORCHI &amp; Upgrade" : "Level Up"))
        set_data(t28, t28_value);
      if (!current || dirty &amp; /*token, balance, levelUpCost, pointsBalance*/
      29 &amp;&amp; button1_disabled_value !== (button1_disabled_value = !/*token*/
      ctx2[0].morchiInfo.canLevelUp || /*balance*/
      ctx2[2] === null || /*levelUpCost*/
      ctx2[4] === null || /*balance*/
      ctx2[2] + /*pointsBalance*/
      ctx2[3] &lt; /*levelUpCost*/
      ctx2[4])) {
        button1.disabled = button1_disabled_value;
      }
      if (
        /*token*/
        ctx2[0].morchiInfo.state.level == 29
      ) {
        if (if_block2)
          ;
        else {
          if_block2 = create_if_block_1$2();
          if_block2.c();
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t12);
        detach(div7);
        detach(t24);
        detach(t25);
        detach(div8);
        detach(t29);
        detach(if_block2_anchor);
      }
      destroy_component(icon);
      if (if_block0) {
        if_block0.d();
      }
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$4(ctx) {
  let div1;
  let div0;
  let h20;
  let t1;
  let icon;
  let t2;
  let h21;
  let t4;
  let img;
  let img_src_value;
  let t5;
  let div2;
  let t7;
  let div3;
  let input;
  let t8;
  let div4;
  let button0;
  let span1;
  let button0_disabled_value;
  let t10;
  let button1;
  let current;
  let mounted;
  let dispose;
  icon = new Icon({
    props: {
      data: ArrowShortSvg,
      width: "32px",
      stroke: "unset"
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      h20 = element("h2");
      h20.textContent = "Lv. 29";
      t1 = space();
      create_component(icon.$$.fragment);
      t2 = space();
      h21 = element("h2");
      h21.textContent = "3 MORCHI Achievement NFTs";
      t4 = space();
      img = element("img");
      t5 = space();
      div2 = element("div");
      div2.innerHTML = `&lt;span class="burn-warning-text svelte-1i3velq"&gt;Please enter BURN and continue the final upgrade.&lt;/span&gt;`;
      t7 = space();
      div3 = element("div");
      input = element("input");
      t8 = space();
      div4 = element("div");
      button0 = element("button");
      span1 = element("span");
      span1.textContent = "Confirm Upgrade";
      t10 = space();
      button1 = element("button");
      button1.innerHTML = `&lt;span&gt;Cancel&lt;/span&gt;`;
      set_style(div0, "display", "flex");
      set_style(div0, "align-items", "center");
      set_style(div0, "gap", "15px");
      attr(img, "alt", "Final Upgrade");
      if (!src_url_equal(img.src, img_src_value = ASSETS_URL + "final_levelup.png"))
        attr(img, "src", img_src_value);
      attr(div1, "class", "row info-box");
      set_style(div1, "display", "flex");
      set_style(div1, "flex-direction", "column");
      attr(div2, "class", "row");
      attr(input, "id", "burn-input");
      attr(input, "placeholder", "Enter BURN to continue");
      set_style(input, "width", "100%");
      set_style(input, "height", "40px");
      set_style(input, "padding", "10px");
      set_style(input, "border-radius", "10px");
      attr(div3, "class", "row");
      attr(button0, "class", "btn btn-primary");
      set_style(button0, "width", "100%");
      button0.disabled = button0_disabled_value = !/*burnTextValid*/
      ctx[6];
      attr(button1, "class", "btn btn-secondary");
      set_style(button1, "width", "100%");
      attr(div4, "class", "row");
      set_style(div4, "display", "flex");
      set_style(div4, "flex-direction", "column");
      set_style(div4, "gap", "20px");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, h20);
      append(div0, t1);
      mount_component(icon, div0, null);
      append(div0, t2);
      append(div0, h21);
      append(div1, t4);
      append(div1, img);
      insert(target, t5, anchor);
      insert(target, div2, anchor);
      insert(target, t7, anchor);
      insert(target, div3, anchor);
      append(div3, input);
      insert(target, t8, anchor);
      insert(target, div4, anchor);
      append(div4, button0);
      append(button0, span1);
      append(div4, t10);
      append(div4, button1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[9]
          ),
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[10]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[11]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty &amp; /*burnTextValid*/
      64 &amp;&amp; button0_disabled_value !== (button0_disabled_value = !/*burnTextValid*/
      ctx2[6])) {
        button0.disabled = button0_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t5);
        detach(div2);
        detach(t7);
        detach(div3);
        detach(t8);
        detach(div4);
      }
      destroy_component(icon);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_4$1(ctx) {
  let img;
  let img_src_value;
  let t0;
  let p;
  return {
    c() {
      img = element("img");
      t0 = space();
      p = element("p");
      p.textContent = "Your MORCHI will be transformed into 3 new Achievement NFTs. One of them will perfectly inherit the rarity and look of your MORCHI.\n					Airdrop and future utilities are coming for MORCHI achievement NFTs holders.";
      attr(img, "alt", "Final Upgrade");
      if (!src_url_equal(img.src, img_src_value = ASSETS_URL + "final_levelup.png"))
        attr(img, "src", img_src_value);
    },
    m(target, anchor) {
      insert(target, img, anchor);
      insert(target, t0, anchor);
      insert(target, p, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(img);
        detach(t0);
        detach(p);
      }
    }
  };
}
function create_if_block_3$1(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "You will increase your earnings by 2 times when you reach level 10.";
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block_2$1(ctx) {
  let small;
  return {
    c() {
      small = element("small");
      small.textContent = "Insufficient funds, earn more points to level-up";
      attr(small, "class", "task-hint-text");
    },
    m(target, anchor) {
      insert(target, small, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(small);
      }
    }
  };
}
function create_if_block_1$2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `&lt;span class="burn-warning-text svelte-1i3velq"&gt;Please note: Your original MORCHI will be burned in return for 3 achievement NFTs&lt;/span&gt;`;
      attr(div, "class", "row");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$7(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$4, create_else_block$2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*showFinalLevelConfirmation*/
      ctx2[5]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () =&gt; {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let { token } = $$props;
  let { levelUpCallback } = $$props;
  let { openSwap } = $$props;
  let balance = null;
  let pointsBalance = 0n;
  let levelUpCost = null;
  let showFinalLevelConfirmation = false;
  let burnTextValid = false;
  const contract = tokenscript.eth.getContractInstance("SUTToken");
  const scoreContract = tokenscript.eth.getContractInstance("MorchiScore");
  onMount(async () =&gt; {
    tokenscript.action.showLoader();
    $$invalidate(3, pointsBalance = BigInt(token.morchiInfo.state.pointsBalance));
    try {
      $$invalidate(4, levelUpCost = await scoreContract.LEVEL_UP_COST(BigInt(token.morchiInfo.state.level) - 1n));
    } catch (e) {
      tokenscript.action.showMessageToast("error", "Loading Error", "There was an error loading level-up cost, please try again later.");
      console.error(e);
    }
    try {
      $$invalidate(2, balance = await contract.balanceOf(token.ownerAddress));
    } catch (e) {
      console.warn("failed to get SUT balance: ", e);
      $$invalidate(2, balance = 0n);
    }
    tokenscript.action.hideLoader();
  });
  async function levelUp() {
    const isBurn = token.morchiInfo.state.level == 29;
    if (pointsBalance &lt; levelUpCost) {
      const approval = await contract.allowance(token.ownerAddress, await scoreContract.getAddress());
      if (pointsBalance + approval &lt; levelUpCost) {
        tokenscript.action.setProps({ approveAmt: levelUpCost - pointsBalance });
        if (!await tokenscript.action.executeTransaction("approveSUT")) {
          return;
        }
      }
    }
    if (isBurn) {
      const nftContract = tokenscript.eth.getContractInstance("Token");
      const approvalAddr = await nftContract.getApproved(token.tokenId);
      if (approvalAddr !== scoreContract.target) {
        if (!await tokenscript.action.executeTransaction("approveNFTBurn")) {
          return;
        }
      }
    }
    if (!await tokenscript.action.executeTransaction("levelUp")) {
      return;
    }
    levelUpCallback(isBurn);
  }
  const keyup_handler = (e) =&gt; {
    var _a;
    $$invalidate(6, burnTextValid = ((_a = document.getElementById("burn-input")) == null ? void 0 : _a.value) === "BURN");
  };
  const click_handler = () =&gt; levelUp();
  const click_handler_1 = () =&gt; $$invalidate(5, showFinalLevelConfirmation = false);
  const click_handler_2 = () =&gt; openSwap();
  const click_handler_3 = () =&gt; {
    if (token.morchiInfo.state.level == 29) {
      $$invalidate(5, showFinalLevelConfirmation = true);
      return;
    }
    levelUp();
  };
  $$self.$$set = ($$props2) =&gt; {
    if ("token" in $$props2)
      $$invalidate(0, token = $$props2.token);
    if ("levelUpCallback" in $$props2)
      $$invalidate(8, levelUpCallback = $$props2.levelUpCallback);
    if ("openSwap" in $$props2)
      $$invalidate(1, openSwap = $$props2.openSwap);
  };
  return [
    token,
    openSwap,
    balance,
    pointsBalance,
    levelUpCost,
    showFinalLevelConfirmation,
    burnTextValid,
    levelUp,
    levelUpCallback,
    keyup_handler,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3
  ];
}
class LevelUpCard extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$6, create_fragment$7, safe_not_equal, {
      token: 0,
      levelUpCallback: 8,
      openSwap: 1
    });
  }
}
const RedeemCard_svelte_svelte_type_style_lang = "";
function create_else_block$1(ctx) {
  let div4;
  let div0;
  let span0;
  let t1;
  let span1;
  let t3;
  let div1;
  let span2;
  let t5;
  let span3;
  let t6_value = (
    /*token*/
    ctx[0].ownerAddress + ""
  );
  let t6;
  let t7;
  let div2;
  let span4;
  let t9;
  let span5;
  let t12;
  let div3;
  let span6;
  let t14;
  let span7;
  let t15_value = Number(ethers.formatEther(
    /*redeemAmt*/
    ctx[2]
  )).toFixed(2) + "";
  let t15;
  let t16;
  let t17;
  let div5;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      span0 = element("span");
      span0.textContent = "From";
      t1 = space();
      span1 = element("span");
      span1.textContent = `${tokenscript.eth.getContractInfo("MorchiScore").address}`;
      t3 = space();
      div1 = element("div");
      span2 = element("span");
      span2.textContent = "To";
      t5 = space();
      span3 = element("span");
      t6 = text(t6_value);
      t7 = space();
      div2 = element("div");
      span4 = element("span");
      span4.textContent = "Fee";
      t9 = space();
      span5 = element("span");
      span5.textContent = `${"0"} $SUT`;
      t12 = space();
      div3 = element("div");
      span6 = element("span");
      span6.textContent = "Amount";
      t14 = space();
      span7 = element("span");
      t15 = text(t15_value);
      t16 = text(" $SUT");
      t17 = space();
      div5 = element("div");
      button = element("button");
      button.innerHTML = `&lt;span&gt;Redeem&lt;/span&gt;`;
      attr(span0, "class", "svelte-15o7gbg");
      set_style(span1, "flex-grow", "1");
      set_style(span1, "text-align", "right");
      attr(span1, "class", "svelte-15o7gbg");
      attr(div0, "class", "balance-row svelte-15o7gbg");
      attr(span2, "class", "svelte-15o7gbg");
      set_style(span3, "flex-grow", "1");
      set_style(span3, "text-align", "right");
      attr(span3, "class", "svelte-15o7gbg");
      attr(div1, "class", "balance-row svelte-15o7gbg");
      attr(span4, "class", "svelte-15o7gbg");
      set_style(span5, "flex-grow", "1");
      set_style(span5, "text-align", "right");
      attr(span5, "class", "svelte-15o7gbg");
      attr(div2, "class", "balance-row svelte-15o7gbg");
      attr(span6, "class", "svelte-15o7gbg");
      set_style(span7, "flex-grow", "1");
      set_style(span7, "text-align", "right");
      attr(span7, "class", "svelte-15o7gbg");
      attr(div3, "class", "balance-row svelte-15o7gbg");
      attr(div4, "class", "row info-box confirm-box svelte-15o7gbg");
      set_style(div4, "display", "flex");
      set_style(div4, "flex-direction", "column");
      attr(button, "class", "btn btn-primary");
      set_style(button, "width", "100%");
      attr(div5, "class", "row");
      set_style(div5, "display", "flex");
      set_style(div5, "flex-direction", "column");
      set_style(div5, "gap", "20px");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      append(div0, span0);
      append(div0, t1);
      append(div0, span1);
      append(div4, t3);
      append(div4, div1);
      append(div1, span2);
      append(div1, t5);
      append(div1, span3);
      append(span3, t6);
      append(div4, t7);
      append(div4, div2);
      append(div2, span4);
      append(div2, t9);
      append(div2, span5);
      append(div4, t12);
      append(div4, div3);
      append(div3, span6);
      append(div3, t14);
      append(div3, span7);
      append(span7, t15);
      append(span7, t16);
      insert(target, t17, anchor);
      insert(target, div5, anchor);
      append(div5, button);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_1*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty &amp; /*token*/
      1 &amp;&amp; t6_value !== (t6_value = /*token*/
      ctx2[0].ownerAddress + ""))
        set_data(t6, t6_value);
      if (dirty &amp; /*redeemAmt*/
      4 &amp;&amp; t15_value !== (t15_value = Number(ethers.formatEther(
        /*redeemAmt*/
        ctx2[2]
      )).toFixed(2) + ""))
        set_data(t15, t15_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
        detach(t17);
        detach(div5);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$3(ctx) {
  let div4;
  let div3;
  let div1;
  let img;
  let img_src_value;
  let t0;
  let div0;
  let strong;
  let t2;
  let small;
  let t3;
  let t4_value = Number(ethers.formatEther(
    /*token*/
    ctx[0].morchiInfo.state.pointsBalance
  )).toFixed(2) + "";
  let t4;
  let t5;
  let div2;
  let input;
  let input_value_value;
  let t6;
  let div5;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      div1 = element("div");
      img = element("img");
      t0 = space();
      div0 = element("div");
      strong = element("strong");
      strong.textContent = "$SUT";
      t2 = space();
      small = element("small");
      t3 = text("Balance: ");
      t4 = text(t4_value);
      t5 = space();
      div2 = element("div");
      input = element("input");
      t6 = space();
      div5 = element("div");
      button = element("button");
      button.innerHTML = `&lt;span&gt;Redeem&lt;/span&gt;`;
      set_style(img, "flex-shrink", "0");
      attr(img, "class", "sut-icon svelte-15o7gbg");
      attr(img, "alt", "SUT");
      if (!src_url_equal(img.src, img_src_value = SUTIcon))
        attr(img, "src", img_src_value);
      set_style(div0, "display", "flex");
      set_style(div0, "flex-direction", "column");
      set_style(div1, "display", "flex");
      attr(input, "type", "number");
      input.value = input_value_value = Number(ethers.formatEther(
        /*redeemAmt*/
        ctx[2]
      )).toFixed(2);
      set_style(div2, "flex-grow", "1");
      set_style(div2, "text-align", "right");
      attr(div3, "class", "balance-row svelte-15o7gbg");
      attr(div4, "class", "row info-box");
      set_style(div4, "display", "flex");
      set_style(div4, "flex-direction", "column");
      attr(button, "class", "btn btn-primary");
      set_style(button, "width", "100%");
      attr(div5, "class", "row");
      set_style(div5, "display", "flex");
      set_style(div5, "flex-direction", "column");
      set_style(div5, "gap", "20px");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, div1);
      append(div1, img);
      append(div1, t0);
      append(div1, div0);
      append(div0, strong);
      append(div0, t2);
      append(div0, small);
      append(small, t3);
      append(small, t4);
      append(div3, t5);
      append(div3, div2);
      append(div2, input);
      insert(target, t6, anchor);
      insert(target, div5, anchor);
      append(div5, button);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*change_handler*/
            ctx[5]
          ),
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty &amp; /*token*/
      1 &amp;&amp; t4_value !== (t4_value = Number(ethers.formatEther(
        /*token*/
        ctx2[0].morchiInfo.state.pointsBalance
      )).toFixed(2) + ""))
        set_data(t4, t4_value);
      if (dirty &amp; /*redeemAmt*/
      4 &amp;&amp; input_value_value !== (input_value_value = Number(ethers.formatEther(
        /*redeemAmt*/
        ctx2[2]
      )).toFixed(2)) &amp;&amp; input.value !== input_value_value) {
        input.value = input_value_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
        detach(t6);
        detach(div5);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$6(ctx) {
  let div;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (!/*showConfirm*/
    ctx2[1])
      return create_if_block$3;
    return create_else_block$1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
      if (!mounted) {
        dispose = listen(
          window,
          "message",
          /*onMessage*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) &amp;&amp; if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$5($$self, $$props, $$invalidate) {
  let { token } = $$props;
  let { redeemedCallback } = $$props;
  let showConfirm = false;
  let redeemAmt = 0n;
  onMount(() =&gt; {
    $$invalidate(2, redeemAmt = BigInt(token.morchiInfo.state.pointsBalance));
  });
  const onMessage = (evt) =&gt; {
    var _a, _b, _c;
    if (((_a = evt.data) == null ? void 0 : _a.method) !== "transactionEvent")
      return;
    console.log("Transaction event", evt.data);
    switch ((_c = (_b = evt.data) == null ? void 0 : _b.params) == null ? void 0 : _c.status) {
      case "confirmed":
        redeemedCallback();
        break;
    }
  };
  const change_handler = (e) =&gt; $$invalidate(2, redeemAmt = ethers.parseUnits(e.target.value, "ether"));
  const click_handler = () =&gt; $$invalidate(1, showConfirm = true);
  const click_handler_1 = () =&gt; {
    tokenscript.action.setProps({ redeemAmt });
    tokenscript.action.executeTransaction("withdrawPointsToSUT");
  };
  $$self.$$set = ($$props2) =&gt; {
    if ("token" in $$props2)
      $$invalidate(0, token = $$props2.token);
    if ("redeemedCallback" in $$props2)
      $$invalidate(4, redeemedCallback = $$props2.redeemedCallback);
  };
  return [
    token,
    showConfirm,
    redeemAmt,
    onMessage,
    redeemedCallback,
    change_handler,
    click_handler,
    click_handler_1
  ];
}
class RedeemCard extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5, create_fragment$6, safe_not_equal, { token: 0, redeemedCallback: 4 });
  }
}
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const Z_FIXED$1 = 4;
const Z_BINARY = 0;
const Z_TEXT = 1;
const Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len &gt;= 0) {
    buf[len] = 0;
  }
}
const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES = 2;
const MIN_MATCH$1 = 3;
const MAX_MATCH$1 = 258;
const LENGTH_CODES$1 = 29;
const LITERALS$1 = 256;
const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
const D_CODES$1 = 30;
const BL_CODES$1 = 19;
const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
const MAX_BITS$1 = 15;
const Buf_size = 16;
const MAX_BL_BITS = 7;
const END_BLOCK = 256;
const REP_3_6 = 16;
const REPZ_3_10 = 17;
const REPZ_11_138 = 18;
const extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
const extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
const extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
const bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
const DIST_CODE_LEN = 512;
const static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
const static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
const _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
const base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
const base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree &amp;&amp; static_tree.length;
}
let static_l_desc;
let static_d_desc;
let static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
const d_code = (dist) =&gt; {
  return dist &lt; 256 ? _dist_code[dist] : _dist_code[256 + (dist &gt;&gt;&gt; 7)];
};
const put_short = (s, w) =&gt; {
  s.pending_buf[s.pending++] = w &amp; 255;
  s.pending_buf[s.pending++] = w &gt;&gt;&gt; 8 &amp; 255;
};
const send_bits = (s, value, length) =&gt; {
  if (s.bi_valid &gt; Buf_size - length) {
    s.bi_buf |= value &lt;&lt; s.bi_valid &amp; 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value &gt;&gt; Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value &lt;&lt; s.bi_valid &amp; 65535;
    s.bi_valid += length;
  }
};
const send_code = (s, c, tree) =&gt; {
  send_bits(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
};
const bi_reverse = (code, len) =&gt; {
  let res = 0;
  do {
    res |= code &amp; 1;
    code &gt;&gt;&gt;= 1;
    res &lt;&lt;= 1;
  } while (--len &gt; 0);
  return res &gt;&gt;&gt; 1;
};
const bi_flush = (s) =&gt; {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid &gt;= 8) {
    s.pending_buf[s.pending++] = s.bi_buf &amp; 255;
    s.bi_buf &gt;&gt;= 8;
    s.bi_valid -= 8;
  }
};
const gen_bitlen = (s, desc) =&gt; {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits &lt;= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h &lt; HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits &gt; max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n &gt; max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n &gt;= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow &gt; 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m &gt; max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
const gen_codes = (tree, max_code, bl_count) =&gt; {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits;
  let n;
  for (bits = 1; bits &lt;= MAX_BITS$1; bits++) {
    code = code + bl_count[bits - 1] &lt;&lt; 1;
    next_code[bits] = code;
  }
  for (n = 0; n &lt;= max_code; n++) {
    let len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
};
const tr_static_init = () =&gt; {
  let n;
  let bits;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code &lt; LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n &lt; 1 &lt;&lt; extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code &lt; 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n &lt; 1 &lt;&lt; extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  dist &gt;&gt;= 7;
  for (; code &lt; D_CODES$1; code++) {
    base_dist[code] = dist &lt;&lt; 7;
    for (n = 0; n &lt; 1 &lt;&lt; extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits &lt;= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n &lt;= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n &lt;= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n &lt;= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n &lt;= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n &lt; D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
const init_block = (s) =&gt; {
  let n;
  for (n = 0; n &lt; L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n &lt; D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n &lt; BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
const bi_windup = (s) =&gt; {
  if (s.bi_valid &gt; 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid &gt; 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
const smaller = (tree, n, m, depth) =&gt; {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree[_n2] &lt; tree[_m2] || tree[_n2] === tree[_m2] &amp;&amp; depth[n] &lt;= depth[m];
};
const pqdownheap = (s, tree, k) =&gt; {
  const v = s.heap[k];
  let j = k &lt;&lt; 1;
  while (j &lt;= s.heap_len) {
    if (j &lt; s.heap_len &amp;&amp; smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j &lt;&lt;= 1;
  }
  s.heap[k] = v;
};
const compress_block = (s, ltree, dtree) =&gt; {
  let dist;
  let lc;
  let sx = 0;
  let code;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] &amp; 255;
      dist += (s.pending_buf[s.sym_buf + sx++] &amp; 255) &lt;&lt; 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (sx &lt; s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
const build_tree = (s, desc) =&gt; {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n &lt; elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len &lt; 2) {
    node = s.heap[++s.heap_len] = max_code &lt; 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len &gt;&gt; 1; n &gt;= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] &gt;= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len &gt;= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
const scan_tree = (s, tree, max_code) =&gt; {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n &lt;= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count &lt; max_count &amp;&amp; curlen === nextlen) {
      continue;
    } else if (count &lt; min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count &lt;= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const send_tree = (s, tree, max_code) =&gt; {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n &lt;= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count &lt; max_count &amp;&amp; curlen === nextlen) {
      continue;
    } else if (count &lt; min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count &lt;= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const build_bl_tree = (s) =&gt; {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex &gt;= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
const send_all_trees = (s, lcodes, dcodes, blcodes) =&gt; {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 &lt; blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
const detect_data_type = (s) =&gt; {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n &lt;= 31; n++, block_mask &gt;&gt;&gt;= 1) {
    if (block_mask &amp; 1 &amp;&amp; s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n &lt; LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
let static_init_done = false;
const _tr_init$1 = (s) =&gt; {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
const _tr_stored_block$1 = (s, buf, stored_len, last) =&gt; {
  send_bits(s, (STORED_BLOCK &lt;&lt; 1) + (last ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
const _tr_align$1 = (s) =&gt; {
  send_bits(s, STATIC_TREES &lt;&lt; 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
const _tr_flush_block$1 = (s, buf, stored_len, last) =&gt; {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level &gt; 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 &gt;&gt;&gt; 3;
    static_lenb = s.static_len + 3 + 7 &gt;&gt;&gt; 3;
    if (static_lenb &lt;= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 &lt;= opt_lenb &amp;&amp; buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES &lt;&lt; 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES &lt;&lt; 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
const _tr_tally$1 = (s, dist, lc) =&gt; {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist &gt;&gt; 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
const adler32 = (adler, buf, len, pos) =&gt; {
  let s1 = adler &amp; 65535 | 0, s2 = adler &gt;&gt;&gt; 16 &amp; 65535 | 0, n = 0;
  while (len !== 0) {
    n = len &gt; 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 &lt;&lt; 16 | 0;
};
var adler32_1 = adler32;
const makeTable = () =&gt; {
  let c, table = [];
  for (var n = 0; n &lt; 256; n++) {
    c = n;
    for (var k = 0; k &lt; 8; k++) {
      c = c &amp; 1 ? 3988292384 ^ c &gt;&gt;&gt; 1 : c &gt;&gt;&gt; 1;
    }
    table[n] = c;
  }
  return table;
};
const crcTable = new Uint32Array(makeTable());
const crc32 = (crc, buf, len, pos) =&gt; {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i &lt; end; i++) {
    crc = crc &gt;&gt;&gt; 8 ^ t[(crc ^ buf[i]) &amp; 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
const MAX_MEM_LEVEL = 9;
const MAX_WBITS$1 = 15;
const DEF_MEM_LEVEL = 8;
const LENGTH_CODES = 29;
const LITERALS = 256;
const L_CODES = LITERALS + 1 + LENGTH_CODES;
const D_CODES = 30;
const BL_CODES = 19;
const HEAP_SIZE = 2 * L_CODES + 1;
const MAX_BITS = 15;
const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
const PRESET_DICT = 32;
const INIT_STATE = 42;
const GZIP_STATE = 57;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;
const BS_NEED_MORE = 1;
const BS_BLOCK_DONE = 2;
const BS_FINISH_STARTED = 3;
const BS_FINISH_DONE = 4;
const OS_CODE = 3;
const err = (strm, errorCode) =&gt; {
  strm.msg = messages[errorCode];
  return errorCode;
};
const rank = (f) =&gt; {
  return f * 2 - (f &gt; 4 ? 9 : 0);
};
const zero = (buf) =&gt; {
  let len = buf.length;
  while (--len &gt;= 0) {
    buf[len] = 0;
  }
};
const slide_hash = (s) =&gt; {
  let n, m;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = m &gt;= wsize ? m - wsize : 0;
  } while (--n);
  n = wsize;
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = m &gt;= wsize ? m - wsize : 0;
  } while (--n);
};
let HASH_ZLIB = (s, prev, data2) =&gt; (prev &lt;&lt; s.hash_shift ^ data2) &amp; s.hash_mask;
let HASH = HASH_ZLIB;
const flush_pending = (strm) =&gt; {
  const s = strm.state;
  let len = s.pending;
  if (len &gt; strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
const flush_block_only = (s, last) =&gt; {
  _tr_flush_block(s, s.block_start &gt;= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
const put_byte = (s, b) =&gt; {
  s.pending_buf[s.pending++] = b;
};
const putShortMSB = (s, b) =&gt; {
  s.pending_buf[s.pending++] = b &gt;&gt;&gt; 8 &amp; 255;
  s.pending_buf[s.pending++] = b &amp; 255;
};
const read_buf = (strm, buf, start, size) =&gt; {
  let len = strm.avail_in;
  if (len &gt; size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
const longest_match = (s, cur_match) =&gt; {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart &gt; s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length &gt;= s.good_match) {
    chain_length &gt;&gt;= 2;
  }
  if (nice_match &gt; s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] &amp;&amp; _win[++scan] === _win[++match] &amp;&amp; _win[++scan] === _win[++match] &amp;&amp; _win[++scan] === _win[++match] &amp;&amp; _win[++scan] === _win[++match] &amp;&amp; _win[++scan] === _win[++match] &amp;&amp; _win[++scan] === _win[++match] &amp;&amp; _win[++scan] === _win[++match] &amp;&amp; scan &lt; strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len &gt; best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len &gt;= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match &amp; wmask]) &gt; limit &amp;&amp; --chain_length !== 0);
  if (best_len &lt;= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
const fill_window = (s) =&gt; {
  const _w_size = s.w_size;
  let n, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart &gt;= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert &gt; s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert &gt;= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str &amp; s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert &lt; MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead &lt; MIN_LOOKAHEAD &amp;&amp; s.strm.avail_in !== 0);
};
const deflate_stored = (s, flush2) =&gt; {
  let min_block = s.pending_buf_size - 5 &gt; s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 &gt;&gt; 3;
    if (s.strm.avail_out &lt; have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len &gt; left + s.strm.avail_in) {
      len = left + s.strm.avail_in;
    }
    if (len &gt; have) {
      len = have;
    }
    if (len &lt; min_block &amp;&amp; (len === 0 &amp;&amp; flush2 !== Z_FINISH$3 || flush2 === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }
    last = flush2 === Z_FINISH$3 &amp;&amp; len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len &gt;&gt; 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len &gt;&gt; 8;
    flush_pending(s.strm);
    if (left) {
      if (left &gt; len) {
        left = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used &gt;= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart &lt;= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches &lt; 2) {
          s.matches++;
        }
        if (s.insert &gt; s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used &gt; s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water &lt; s.strstart) {
    s.high_water = s.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush2 !== Z_NO_FLUSH$2 &amp;&amp; flush2 !== Z_FINISH$3 &amp;&amp; s.strm.avail_in === 0 &amp;&amp; s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in &gt; have &amp;&amp; s.block_start &gt;= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches &lt; 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert &gt; s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have &gt; s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have &gt; s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water &lt; s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 &gt;&gt; 3;
  have = s.pending_buf_size - have &gt; 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have &gt; s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left &gt;= min_block || (left || flush2 === Z_FINISH$3) &amp;&amp; flush2 !== Z_NO_FLUSH$2 &amp;&amp; s.strm.avail_in === 0 &amp;&amp; left &lt;= have) {
    len = left &gt; have ? have : left;
    last = flush2 === Z_FINISH$3 &amp;&amp; s.strm.avail_in === 0 &amp;&amp; len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
const deflate_fast = (s, flush2) =&gt; {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead &lt; MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead &lt; MIN_LOOKAHEAD &amp;&amp; flush2 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead &gt;= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart &amp; s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 &amp;&amp; s.strstart - hash_head &lt;= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length &gt;= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length &lt;= s.max_lazy_match &amp;&amp; s.lookahead &gt;= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart &amp; s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart &lt; MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush2 === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_slow = (s, flush2) =&gt; {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead &lt; MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead &lt; MIN_LOOKAHEAD &amp;&amp; flush2 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead &gt;= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart &amp; s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 &amp;&amp; s.prev_length &lt; s.max_lazy_match &amp;&amp; s.strstart - hash_head &lt;= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length &lt;= 5 &amp;&amp; (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH &amp;&amp; s.strstart - s.match_start &gt; 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length &gt;= MIN_MATCH &amp;&amp; s.match_length &lt;= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart &lt;= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart &amp; s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart &lt; MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush2 === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_rle = (s, flush2) =&gt; {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead &lt;= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead &lt;= MAX_MATCH &amp;&amp; flush2 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead &gt;= MIN_MATCH &amp;&amp; s.strstart &gt; 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp; prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp; scan &lt; strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length &gt; s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length &gt;= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush2 === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_huff = (s, flush2) =&gt; {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush2 === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush2 === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func2) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func2;
}
const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
const lm_init = (s) =&gt; {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
const deflateStateCheck = (strm) =&gt; {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE &amp;&amp; //#ifdef GZIP
  s.status !== GZIP_STATE &amp;&amp; //#endif
  s.status !== EXTRA_STATE &amp;&amp; s.status !== NAME_STATE &amp;&amp; s.status !== COMMENT_STATE &amp;&amp; s.status !== HCRC_STATE &amp;&amp; s.status !== BUSY_STATE &amp;&amp; s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
const deflateResetKeep = (strm) =&gt; {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap &lt; 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE : (
    //#endif
    s.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
const deflateReset = (strm) =&gt; {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
const deflateSetHeader = (strm, head) =&gt; {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) =&gt; {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits &lt; 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits &gt; 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel &lt; 1 || memLevel &gt; MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits &lt; 8 || windowBits &gt; 15 || level &lt; 0 || level &gt; 9 || strategy &lt; 0 || strategy &gt; Z_FIXED || windowBits === 8 &amp;&amp; wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 &lt;&lt; s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 &lt;&lt; s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 &lt;&lt; memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
const deflateInit = (strm, level) =&gt; {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
const deflate$2 = (strm, flush2) =&gt; {
  if (deflateStateCheck(strm) || flush2 &gt; Z_BLOCK$1 || flush2 &lt; 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 &amp;&amp; !strm.input || s.status === FINISH_STATE &amp;&amp; flush2 !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush2;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 &amp;&amp; rank(flush2) &lt;= rank(old_flush) &amp;&amp; flush2 !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE &amp;&amp; strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE &amp;&amp; s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 &lt;&lt; 4) &lt;&lt; 8;
    let level_flags = -1;
    if (s.strategy &gt;= Z_HUFFMAN_ONLY || s.level &lt; 2) {
      level_flags = 0;
    } else if (s.level &lt; 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags &lt;&lt; 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler &gt;&gt;&gt; 16);
      putShortMSB(s, strm.adler &amp; 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy &gt;= Z_HUFFMAN_ONLY || s.level &lt; 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time &amp; 255);
      put_byte(s, s.gzhead.time &gt;&gt; 8 &amp; 255);
      put_byte(s, s.gzhead.time &gt;&gt; 16 &amp; 255);
      put_byte(s, s.gzhead.time &gt;&gt; 24 &amp; 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy &gt;= Z_HUFFMAN_ONLY || s.level &lt; 2 ? 4 : 0);
      put_byte(s, s.gzhead.os &amp; 255);
      if (s.gzhead.extra &amp;&amp; s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length &amp; 255);
        put_byte(s, s.gzhead.extra.length &gt;&gt; 8 &amp; 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length &amp; 65535) - s.gzindex;
      while (s.pending + left &gt; s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc &amp;&amp; s.pending &gt; beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc &amp;&amp; s.pending &gt; beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc &amp;&amp; s.pending &gt; beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex &lt; s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) &amp; 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc &amp;&amp; s.pending &gt; beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc &amp;&amp; s.pending &gt; beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex &lt; s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) &amp; 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc &amp;&amp; s.pending &gt; beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 &gt; s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler &amp; 255);
      put_byte(s, strm.adler &gt;&gt; 8 &amp; 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush2 !== Z_NO_FLUSH$2 &amp;&amp; s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush2) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush2) : s.strategy === Z_RLE ? deflate_rle(s, flush2) : configuration_table[s.level].func(s, flush2);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush2 === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush2 !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush2 === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush2 !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap &lt;= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler &amp; 255);
    put_byte(s, strm.adler &gt;&gt; 8 &amp; 255);
    put_byte(s, strm.adler &gt;&gt; 16 &amp; 255);
    put_byte(s, strm.adler &gt;&gt; 24 &amp; 255);
    put_byte(s, strm.total_in &amp; 255);
    put_byte(s, strm.total_in &gt;&gt; 8 &amp; 255);
    put_byte(s, strm.total_in &gt;&gt; 16 &amp; 255);
    put_byte(s, strm.total_in &gt;&gt; 24 &amp; 255);
  } else {
    putShortMSB(s, strm.adler &gt;&gt;&gt; 16);
    putShortMSB(s, strm.adler &amp; 65535);
  }
  flush_pending(strm);
  if (s.wrap &gt; 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
const deflateEnd = (strm) =&gt; {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
const deflateSetDictionary = (strm, dictionary) =&gt; {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 &amp;&amp; s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength &gt;= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead &gt;= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str &amp; s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
const _has = (obj, key) =&gt; {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) =&gt; {
  let len = 0;
  for (let i = 0, l = chunks.length; i &lt; l; i++) {
    len += chunks[i].length;
  }
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l = chunks.length; i &lt; l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
let STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
const _utf8len = new Uint8Array(256);
for (let q = 0; q &lt; 256; q++) {
  _utf8len[q] = q &gt;= 252 ? 6 : q &gt;= 248 ? 5 : q &gt;= 240 ? 4 : q &gt;= 224 ? 3 : q &gt;= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) =&gt; {
  if (typeof TextEncoder === "function" &amp;&amp; TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos &lt; str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c &amp; 64512) === 55296 &amp;&amp; m_pos + 1 &lt; str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 &amp; 64512) === 56320) {
        c = 65536 + (c - 55296 &lt;&lt; 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c &lt; 128 ? 1 : c &lt; 2048 ? 2 : c &lt; 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i &lt; buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c &amp; 64512) === 55296 &amp;&amp; m_pos + 1 &lt; str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 &amp; 64512) === 56320) {
        c = 65536 + (c - 55296 &lt;&lt; 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c &lt; 128) {
      buf[i++] = c;
    } else if (c &lt; 2048) {
      buf[i++] = 192 | c &gt;&gt;&gt; 6;
      buf[i++] = 128 | c &amp; 63;
    } else if (c &lt; 65536) {
      buf[i++] = 224 | c &gt;&gt;&gt; 12;
      buf[i++] = 128 | c &gt;&gt;&gt; 6 &amp; 63;
      buf[i++] = 128 | c &amp; 63;
    } else {
      buf[i++] = 240 | c &gt;&gt;&gt; 18;
      buf[i++] = 128 | c &gt;&gt;&gt; 12 &amp; 63;
      buf[i++] = 128 | c &gt;&gt;&gt; 6 &amp; 63;
      buf[i++] = 128 | c &amp; 63;
    }
  }
  return buf;
};
const buf2binstring = (buf, len) =&gt; {
  if (len &lt; 65534) {
    if (buf.subarray &amp;&amp; STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i = 0; i &lt; len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
var buf2string = (buf, max) =&gt; {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" &amp;&amp; TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i &lt; len; ) {
    let c = buf[i++];
    if (c &lt; 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len &gt; 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &amp;= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len &gt; 1 &amp;&amp; i &lt; len) {
      c = c &lt;&lt; 6 | buf[i++] &amp; 63;
      c_len--;
    }
    if (c_len &gt; 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c &lt; 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c &gt;&gt; 10 &amp; 1023;
      utf16buf[out++] = 56320 | c &amp; 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) =&gt; {
  max = max || buf.length;
  if (max &gt; buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos &gt;= 0 &amp;&amp; (buf[pos] &amp; 192) === 128) {
    pos--;
  }
  if (pos &lt; 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] &gt; max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
const toString$1 = Object.prototype.toString;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw &amp;&amp; opt.windowBits &gt; 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip &amp;&amp; opt.windowBits &gt; 0 &amp;&amp; opt.windowBits &lt; 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data2, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data2 === "string") {
    strm.input = strings.string2buf(data2);
  } else if (toString$1.call(data2) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data2);
  } else {
    strm.input = data2;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) &amp;&amp; strm.avail_out &lt;= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out &gt; 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode &gt; 0 &amp;&amp; strm.next_out &gt; 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};
const BAD$1 = 16209;
const TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 &lt;&lt; state.lenbits) - 1;
  dmask = (1 &lt;&lt; state.distbits) - 1;
  top:
    do {
      if (bits &lt; 15) {
        hold += input[_in++] &lt;&lt; bits;
        bits += 8;
        hold += input[_in++] &lt;&lt; bits;
        bits += 8;
      }
      here = lcode[hold &amp; lmask];
      dolen:
        for (; ; ) {
          op = here &gt;&gt;&gt; 24;
          hold &gt;&gt;&gt;= op;
          bits -= op;
          op = here &gt;&gt;&gt; 16 &amp; 255;
          if (op === 0) {
            output[_out++] = here &amp; 65535;
          } else if (op &amp; 16) {
            len = here &amp; 65535;
            op &amp;= 15;
            if (op) {
              if (bits &lt; op) {
                hold += input[_in++] &lt;&lt; bits;
                bits += 8;
              }
              len += hold &amp; (1 &lt;&lt; op) - 1;
              hold &gt;&gt;&gt;= op;
              bits -= op;
            }
            if (bits &lt; 15) {
              hold += input[_in++] &lt;&lt; bits;
              bits += 8;
              hold += input[_in++] &lt;&lt; bits;
              bits += 8;
            }
            here = dcode[hold &amp; dmask];
            dodist:
              for (; ; ) {
                op = here &gt;&gt;&gt; 24;
                hold &gt;&gt;&gt;= op;
                bits -= op;
                op = here &gt;&gt;&gt; 16 &amp; 255;
                if (op &amp; 16) {
                  dist = here &amp; 65535;
                  op &amp;= 15;
                  if (bits &lt; op) {
                    hold += input[_in++] &lt;&lt; bits;
                    bits += 8;
                    if (bits &lt; op) {
                      hold += input[_in++] &lt;&lt; bits;
                      bits += 8;
                    }
                  }
                  dist += hold &amp; (1 &lt;&lt; op) - 1;
                  if (dist &gt; dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold &gt;&gt;&gt;= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist &gt; op) {
                    op = dist - op;
                    if (op &gt; whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op &lt; len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext &lt; op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op &lt; len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext &lt; len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op &lt; len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len &gt; 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len &gt; 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len &gt; 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len &gt; 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op &amp; 64) === 0) {
                  here = dcode[(here &amp; 65535) + (hold &amp; (1 &lt;&lt; op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op &amp; 64) === 0) {
            here = lcode[(here &amp; 65535) + (hold &amp; (1 &lt;&lt; op) - 1)];
            continue dolen;
          } else if (op &amp; 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in &lt; last &amp;&amp; _out &lt; end);
  len = bits &gt;&gt; 3;
  _in -= len;
  bits -= len &lt;&lt; 3;
  hold &amp;= (1 &lt;&lt; bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in &lt; last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out &lt; end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;
const lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
const lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
const dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
const dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =&gt; {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len &lt;= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym &lt; codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max &gt;= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root &gt; max) {
    root = max;
  }
  if (max === 0) {
    table[table_index++] = 1 &lt;&lt; 24 | 64 &lt;&lt; 16 | 0;
    table[table_index++] = 1 &lt;&lt; 24 | 64 &lt;&lt; 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min &lt; max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root &lt; min) {
    root = min;
  }
  left = 1;
  for (len = 1; len &lt;= MAXBITS; len++) {
    left &lt;&lt;= 1;
    left -= count[len];
    if (left &lt; 0) {
      return -1;
    }
  }
  if (left &gt; 0 &amp;&amp; (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len &lt; MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym &lt; codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    match = 20;
  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;
  } else {
    base = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 &lt;&lt; root;
  mask = used - 1;
  if (type === LENS$1 &amp;&amp; used &gt; ENOUGH_LENS$1 || type === DISTS$1 &amp;&amp; used &gt; ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 &lt; match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] &gt;= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 &lt;&lt; len - drop;
    fill = 1 &lt;&lt; curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff &gt;&gt; drop) + fill] = here_bits &lt;&lt; 24 | here_op &lt;&lt; 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 &lt;&lt; len - 1;
    while (huff &amp; incr) {
      incr &gt;&gt;= 1;
    }
    if (incr !== 0) {
      huff &amp;= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len &gt; root &amp;&amp; (huff &amp; mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left = 1 &lt;&lt; curr;
      while (curr + drop &lt; max) {
        left -= count[curr + drop];
        if (left &lt;= 0) {
          break;
        }
        curr++;
        left &lt;&lt;= 1;
      }
      used += 1 &lt;&lt; curr;
      if (type === LENS$1 &amp;&amp; used &gt; ENOUGH_LENS$1 || type === DISTS$1 &amp;&amp; used &gt; ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff &amp; mask;
      table[low] = root &lt;&lt; 24 | curr &lt;&lt; 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop &lt;&lt; 24 | 64 &lt;&lt; 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
const CODES = 0;
const LENS = 1;
const DISTS = 2;
const {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
const HEAD = 16180;
const FLAGS = 16181;
const TIME = 16182;
const OS = 16183;
const EXLEN = 16184;
const EXTRA = 16185;
const NAME = 16186;
const COMMENT = 16187;
const HCRC = 16188;
const DICTID = 16189;
const DICT = 16190;
const TYPE = 16191;
const TYPEDO = 16192;
const STORED = 16193;
const COPY_ = 16194;
const COPY = 16195;
const TABLE = 16196;
const LENLENS = 16197;
const CODELENS = 16198;
const LEN_ = 16199;
const LEN = 16200;
const LENEXT = 16201;
const DIST = 16202;
const DISTEXT = 16203;
const MATCH = 16204;
const LIT = 16205;
const CHECK = 16206;
const LENGTH = 16207;
const DONE = 16208;
const BAD = 16209;
const MEM = 16210;
const SYNC = 16211;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
const MAX_WBITS = 15;
const DEF_WBITS = MAX_WBITS;
const zswap32 = (q) =&gt; {
  return (q &gt;&gt;&gt; 24 &amp; 255) + (q &gt;&gt;&gt; 8 &amp; 65280) + ((q &amp; 65280) &lt;&lt; 8) + ((q &amp; 255) &lt;&lt; 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
const inflateStateCheck = (strm) =&gt; {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode &lt; HEAD || state.mode &gt; SYNC) {
    return 1;
  }
  return 0;
};
const inflateResetKeep = (strm) =&gt; {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap &amp; 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
const inflateReset = (strm) =&gt; {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
const inflateReset2 = (strm, windowBits) =&gt; {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits &lt; 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits &gt;&gt; 4) + 5;
    if (windowBits &lt; 48) {
      windowBits &amp;= 15;
    }
  }
  if (windowBits &amp;&amp; (windowBits &lt; 8 || windowBits &gt; 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null &amp;&amp; state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
const inflateInit2 = (strm, windowBits) =&gt; {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
const inflateInit = (strm) =&gt; {
  return inflateInit2(strm, DEF_WBITS);
};
let virgin = true;
let lenfix, distfix;
const fixedtables = (state) =&gt; {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym &lt; 144) {
      state.lens[sym++] = 8;
    }
    while (sym &lt; 256) {
      state.lens[sym++] = 9;
    }
    while (sym &lt; 280) {
      state.lens[sym++] = 7;
    }
    while (sym &lt; 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym &lt; 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
const updatewindow = (strm, src, end, copy) =&gt; {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 &lt;&lt; state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy &gt;= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist &gt; copy) {
      dist = copy;
    }
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave &lt; state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
const inflate$2 = (strm, flush2) =&gt; {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input &amp;&amp; strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits &lt; 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] &lt;&lt; bits;
            bits += 8;
          }
          if (state.wrap &amp; 2 &amp;&amp; hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold &amp; 255;
            hbuf[1] = hold &gt;&gt;&gt; 8 &amp; 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap &amp; 1) || /* check if zlib header allowed */
          (((hold &amp; 255) &lt;&lt; 8) + (hold &gt;&gt; 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold &amp; 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold &gt;&gt;&gt;= 4;
          bits -= 4;
          len = (hold &amp; 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len &gt; 15 || len &gt; state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 &lt;&lt; state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold &amp; 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits &lt; 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] &lt;&lt; bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags &amp; 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags &amp; 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold &gt;&gt; 8 &amp; 1;
          }
          if (state.flags &amp; 512 &amp;&amp; state.wrap &amp; 4) {
            hbuf[0] = hold &amp; 255;
            hbuf[1] = hold &gt;&gt;&gt; 8 &amp; 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        case TIME:
          while (bits &lt; 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] &lt;&lt; bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags &amp; 512 &amp;&amp; state.wrap &amp; 4) {
            hbuf[0] = hold &amp; 255;
            hbuf[1] = hold &gt;&gt;&gt; 8 &amp; 255;
            hbuf[2] = hold &gt;&gt;&gt; 16 &amp; 255;
            hbuf[3] = hold &gt;&gt;&gt; 24 &amp; 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        case OS:
          while (bits &lt; 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] &lt;&lt; bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold &amp; 255;
            state.head.os = hold &gt;&gt; 8;
          }
          if (state.flags &amp; 512 &amp;&amp; state.wrap &amp; 4) {
            hbuf[0] = hold &amp; 255;
            hbuf[1] = hold &gt;&gt;&gt; 8 &amp; 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags &amp; 1024) {
            while (bits &lt; 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] &lt;&lt; bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags &amp; 512 &amp;&amp; state.wrap &amp; 4) {
              hbuf[0] = hold &amp; 255;
              hbuf[1] = hold &gt;&gt;&gt; 8 &amp; 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags &amp; 1024) {
            copy = state.length;
            if (copy &gt; have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy
                  ),
                  /*len + copy &gt; state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags &amp; 512 &amp;&amp; state.wrap &amp; 4) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags &amp; 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head &amp;&amp; len &amp;&amp; state.length &lt; 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len &amp;&amp; copy &lt; have);
            if (state.flags &amp; 512 &amp;&amp; state.wrap &amp; 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags &amp; 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head &amp;&amp; len &amp;&amp; state.length &lt; 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len &amp;&amp; copy &lt; have);
            if (state.flags &amp; 512 &amp;&amp; state.wrap &amp; 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags &amp; 512) {
            while (bits &lt; 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] &lt;&lt; bits;
              bits += 8;
            }
            if (state.wrap &amp; 4 &amp;&amp; hold !== (state.check &amp; 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags &gt;&gt; 9 &amp; 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits &lt; 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] &lt;&lt; bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush2 === Z_BLOCK || flush2 === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold &gt;&gt;&gt;= bits &amp; 7;
            bits -= bits &amp; 7;
            state.mode = CHECK;
            break;
          }
          while (bits &lt; 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] &lt;&lt; bits;
            bits += 8;
          }
          state.last = hold &amp; 1;
          hold &gt;&gt;&gt;= 1;
          bits -= 1;
          switch (hold &amp; 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush2 === Z_TREES) {
                hold &gt;&gt;&gt;= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold &gt;&gt;&gt;= 2;
          bits -= 2;
          break;
        case STORED:
          hold &gt;&gt;&gt;= bits &amp; 7;
          bits -= bits &amp; 7;
          while (bits &lt; 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] &lt;&lt; bits;
            bits += 8;
          }
          if ((hold &amp; 65535) !== (hold &gt;&gt;&gt; 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold &amp; 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush2 === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy &gt; have) {
              copy = have;
            }
            if (copy &gt; left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits &lt; 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] &lt;&lt; bits;
            bits += 8;
          }
          state.nlen = (hold &amp; 31) + 257;
          hold &gt;&gt;&gt;= 5;
          bits -= 5;
          state.ndist = (hold &amp; 31) + 1;
          hold &gt;&gt;&gt;= 5;
          bits -= 5;
          state.ncode = (hold &amp; 15) + 4;
          hold &gt;&gt;&gt;= 4;
          bits -= 4;
          if (state.nlen &gt; 286 || state.ndist &gt; 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have &lt; state.ncode) {
            while (bits &lt; 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] &lt;&lt; bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold &amp; 7;
            hold &gt;&gt;&gt;= 3;
            bits -= 3;
          }
          while (state.have &lt; 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have &lt; state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold &amp; (1 &lt;&lt; state.lenbits) - 1];
              here_bits = here &gt;&gt;&gt; 24;
              here_op = here &gt;&gt;&gt; 16 &amp; 255;
              here_val = here &amp; 65535;
              if (here_bits &lt;= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] &lt;&lt; bits;
              bits += 8;
            }
            if (here_val &lt; 16) {
              hold &gt;&gt;&gt;= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits &lt; n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] &lt;&lt; bits;
                  bits += 8;
                }
                hold &gt;&gt;&gt;= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold &amp; 3);
                hold &gt;&gt;&gt;= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits &lt; n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] &lt;&lt; bits;
                  bits += 8;
                }
                hold &gt;&gt;&gt;= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold &amp; 7);
                hold &gt;&gt;&gt;= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits &lt; n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] &lt;&lt; bits;
                  bits += 8;
                }
                hold &gt;&gt;&gt;= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold &amp; 127);
                hold &gt;&gt;&gt;= 7;
                bits -= 7;
              }
              if (state.have + copy &gt; state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush2 === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have &gt;= 6 &amp;&amp; left &gt;= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold &amp; (1 &lt;&lt; state.lenbits) - 1];
            here_bits = here &gt;&gt;&gt; 24;
            here_op = here &gt;&gt;&gt; 16 &amp; 255;
            here_val = here &amp; 65535;
            if (here_bits &lt;= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] &lt;&lt; bits;
            bits += 8;
          }
          if (here_op &amp;&amp; (here_op &amp; 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold &amp; (1 &lt;&lt; last_bits + last_op) - 1) &gt;&gt; last_bits)];
              here_bits = here &gt;&gt;&gt; 24;
              here_op = here &gt;&gt;&gt; 16 &amp; 255;
              here_val = here &amp; 65535;
              if (last_bits + here_bits &lt;= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] &lt;&lt; bits;
              bits += 8;
            }
            hold &gt;&gt;&gt;= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold &gt;&gt;&gt;= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op &amp; 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op &amp; 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op &amp; 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits &lt; n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] &lt;&lt; bits;
              bits += 8;
            }
            state.length += hold &amp; (1 &lt;&lt; state.extra) - 1;
            hold &gt;&gt;&gt;= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold &amp; (1 &lt;&lt; state.distbits) - 1];
            here_bits = here &gt;&gt;&gt; 24;
            here_op = here &gt;&gt;&gt; 16 &amp; 255;
            here_val = here &amp; 65535;
            if (here_bits &lt;= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] &lt;&lt; bits;
            bits += 8;
          }
          if ((here_op &amp; 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold &amp; (1 &lt;&lt; last_bits + last_op) - 1) &gt;&gt; last_bits)];
              here_bits = here &gt;&gt;&gt; 24;
              here_op = here &gt;&gt;&gt; 16 &amp; 255;
              here_val = here &amp; 65535;
              if (last_bits + here_bits &lt;= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] &lt;&lt; bits;
              bits += 8;
            }
            hold &gt;&gt;&gt;= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold &gt;&gt;&gt;= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op &amp; 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op &amp; 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits &lt; n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] &lt;&lt; bits;
              bits += 8;
            }
            state.offset += hold &amp; (1 &lt;&lt; state.extra) - 1;
            hold &gt;&gt;&gt;= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset &gt; state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset &gt; copy) {
            copy = state.offset - copy;
            if (copy &gt; state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy &gt; state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy &gt; state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy &gt; left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits &lt; 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] &lt;&lt; bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap &amp; 4 &amp;&amp; _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if (state.wrap &amp; 4 &amp;&amp; (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap &amp;&amp; state.flags) {
            while (bits &lt; 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] &lt;&lt; bits;
              bits += 8;
            }
            if (state.wrap &amp; 4 &amp;&amp; hold !== (state.total &amp; 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out &amp;&amp; state.mode &lt; BAD &amp;&amp; (state.mode &lt; CHECK || flush2 !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap &amp; 4 &amp;&amp; _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 &amp;&amp; _out === 0 || flush2 === Z_FINISH$1) &amp;&amp; ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
const inflateEnd = (strm) =&gt; {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
const inflateGetHeader = (strm, head) =&gt; {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap &amp; 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
const inflateSetDictionary = (strm, dictionary) =&gt; {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 &amp;&amp; state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
const toString = Object.prototype.toString;
const {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw &amp;&amp; opt.windowBits &gt;= 0 &amp;&amp; opt.windowBits &lt; 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits &gt;= 0 &amp;&amp; opt.windowBits &lt; 16 &amp;&amp; !(options &amp;&amp; options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits &gt; 15 &amp;&amp; opt.windowBits &lt; 48) {
    if ((opt.windowBits &amp; 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data2, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended)
    return false;
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString.call(data2) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data2);
  } else {
    strm.input = data2;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT &amp;&amp; dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in &gt; 0 &amp;&amp; status === Z_STREAM_END &amp;&amp; strm.state.wrap &gt; 0 &amp;&amp; data2[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail)
            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK &amp;&amp; last_avail_out === 0)
      continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants
};
const { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var Deflate_1 = Deflate;
var deflate_1 = deflate;
var deflateRaw_1 = deflateRaw;
var gzip_1 = gzip;
var Inflate_1 = Inflate;
var inflate_1 = inflate;
var inflateRaw_1 = inflateRaw;
var ungzip_1 = ungzip;
var constants_1 = constants$2;
var pako = {
  Deflate: Deflate_1,
  deflate: deflate_1,
  deflateRaw: deflateRaw_1,
  gzip: gzip_1,
  Inflate: Inflate_1,
  inflate: inflate_1,
  inflateRaw: inflateRaw_1,
  ungzip: ungzip_1,
  constants: constants_1
};
function create_fragment$5(ctx) {
  let html_tag;
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(
        /*timerValue*/
        ctx[0],
        target,
        anchor
      );
      insert(target, html_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty &amp; /*timerValue*/
      1)
        html_tag.p(
          /*timerValue*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let { epochMs } = $$props;
  let nowEpochMs;
  let timerValue = "";
  let timer;
  onMount(() =&gt; {
    timer = setInterval(
      () =&gt; {
        nowEpochMs = Date.now();
        updateTimerValue();
      },
      1e3
    );
  });
  function updateTimerValue() {
    if (epochMs &lt; nowEpochMs) {
      $$invalidate(0, timerValue = "");
      clearInterval(timer);
      return;
    }
    const dueDate = new Date(epochMs);
    const deltaMs = epochMs - nowEpochMs;
    const totalSeconds = Math.floor(deltaMs / 1e3);
    const totalMinutes = Math.floor(totalSeconds / 60);
    const hours = Math.floor(totalMinutes / 60);
    const seconds = totalSeconds % 60;
    const minutes = totalMinutes % 60;
    $$invalidate(0, timerValue = `
			&lt;small  class="task-hint-text" title="${dueDate.toLocaleString()}"&gt;
				Tasks refreshing in ${(hours &lt; 10 ? "0" : "") + hours}:${(minutes &lt; 10 ? "0" : "") + minutes}:${(seconds &lt; 10 ? "0" : "") + seconds}
			&lt;/small&gt;
		`);
  }
  onDestroy(() =&gt; {
    clearInterval(timer);
  });
  $$self.$$set = ($$props2) =&gt; {
    if ("epochMs" in $$props2)
      $$invalidate(1, epochMs = $$props2.epochMs);
  };
  return [timerValue, epochMs];
}
class CountdownTimer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4, create_fragment$5, safe_not_equal, { epochMs: 1 });
  }
}
const GMTIcon = "data:image/png;base64,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";
const ArrowSvg = '&lt;svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"&gt;\n&lt;path d="M12 4L10.59 5.41L16.17 11H4V13H16.17L10.59 18.59L12 20L20 12L12 4Z" fill="url(#paint0_linear_755_462)"/&gt;\n&lt;defs&gt;\n&lt;linearGradient id="paint0_linear_755_462" x1="3.34694" y1="10.4416" x2="19.3798" y2="15.2954" gradientUnits="userSpaceOnUse"&gt;\n&lt;stop stop-color="#FF8C4A"/&gt;\n&lt;stop offset="1" stop-color="#FF605F"/&gt;\n&lt;/linearGradient&gt;\n&lt;/defs&gt;\n&lt;/svg&gt;\n';
const DooarSwap_svelte_svelte_type_style_lang = "";
function create_if_block_1$1(ctx) {
  let small;
  return {
    c() {
      small = element("small");
      small.textContent = "Insufficient balance";
      attr(small, "class", "task-hint-text svelte-2n429h");
      set_style(small, "text-align", "center");
    },
    m(target, anchor) {
      insert(target, small, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(small);
      }
    }
  };
}
function create_default_slot_1$1(ctx) {
  let button0;
  let span0;
  let button0_disabled_value;
  let t1;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      span0 = element("span");
      span0.textContent = "Swap";
      t1 = space();
      button1 = element("button");
      button1.innerHTML = `&lt;span class="svelte-2n429h"&gt;Settings&lt;/span&gt;`;
      attr(span0, "class", "svelte-2n429h");
      attr(button0, "class", "btn btn-primary svelte-2n429h");
      set_style(button0, "flex", "100%");
      button0.disabled = button0_disabled_value = !/*swapAmtLeft*/
      ctx[0] || !/*swapAmtRight*/
      ctx[1] || /*quoteLoading*/
      ctx[3] || /*swapAmtLeft*/
      ctx[0] &gt; /*gmtBalance*/
      ctx[5];
      attr(button1, "class", "btn btn-secondary svelte-2n429h");
      set_style(button1, "flex", "100%");
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      append(button0, span0);
      insert(target, t1, anchor);
      insert(target, button1, anchor);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[13]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[14]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty &amp; /*swapAmtLeft, swapAmtRight, quoteLoading, gmtBalance*/
      43 &amp;&amp; button0_disabled_value !== (button0_disabled_value = !/*swapAmtLeft*/
      ctx2[0] || !/*swapAmtRight*/
      ctx2[1] || /*quoteLoading*/
      ctx2[3] || /*swapAmtLeft*/
      ctx2[0] &gt; /*gmtBalance*/
      ctx2[5])) {
        button0.disabled = button0_disabled_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t1);
        detach(button1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$2(ctx) {
  let popovermodal;
  let current;
  popovermodal = new PopoverModal({
    props: {
      title: "Swap settings",
      hideTitleBar: true,
      dismissCallback: (
        /*func*/
        ctx[20]
      ),
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popovermodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popovermodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const popovermodal_changes = {};
      if (dirty &amp; /*settingsOpen*/
      16)
        popovermodal_changes.dismissCallback = /*func*/
        ctx2[20];
      if (dirty &amp; /*$$scope, slippageBps, settingsOpen*/
      268435476) {
        popovermodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popovermodal.$set(popovermodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(popovermodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popovermodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popovermodal, detaching);
    }
  };
}
function create_default_slot$1(ctx) {
  let div0;
  let h2;
  let t1;
  let h1;
  let t3;
  let div1;
  let button0;
  let t5;
  let button1;
  let t7;
  let button2;
  let t9;
  let div2;
  let input;
  let input_value_value;
  let t10;
  let strong;
  let mounted;
  let dispose;
  return {
    c() {
      div0 = element("div");
      h2 = element("h2");
      h2.textContent = "Slippage Tolerance";
      t1 = space();
      h1 = element("h1");
      h1.textContent = "X";
      t3 = space();
      div1 = element("div");
      button0 = element("button");
      button0.textContent = "0.5%";
      t5 = space();
      button1 = element("button");
      button1.textContent = "1%";
      t7 = space();
      button2 = element("button");
      button2.textContent = "5%";
      t9 = space();
      div2 = element("div");
      input = element("input");
      t10 = space();
      strong = element("strong");
      strong.textContent = "%";
      set_style(h2, "flex-grow", "1");
      attr(h2, "class", "svelte-2n429h");
      attr(h1, "class", "close-btn svelte-2n429h");
      attr(div0, "class", "slippage-header svelte-2n429h");
      attr(button0, "class", "btn svelte-2n429h");
      attr(button1, "class", "btn svelte-2n429h");
      attr(button2, "class", "btn svelte-2n429h");
      attr(div1, "class", "row slippage-opts svelte-2n429h");
      attr(input, "type", "number");
      input.value = input_value_value = Number(
        /*slippageBps*/
        ctx[2]
      ) / 100;
      attr(input, "class", "svelte-2n429h");
      attr(strong, "class", "svelte-2n429h");
      attr(div2, "class", "row slippage-input svelte-2n429h");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, h2);
      append(div0, t1);
      append(div0, h1);
      insert(target, t3, anchor);
      insert(target, div1, anchor);
      append(div1, button0);
      append(div1, t5);
      append(div1, button1);
      append(div1, t7);
      append(div1, button2);
      insert(target, t9, anchor);
      insert(target, div2, anchor);
      append(div2, input);
      append(div2, t10);
      append(div2, strong);
      if (!mounted) {
        dispose = [
          listen(
            h1,
            "click",
            /*click_handler_2*/
            ctx[15]
          ),
          listen(
            button0,
            "click",
            /*click_handler_3*/
            ctx[16]
          ),
          listen(
            button1,
            "click",
            /*click_handler_4*/
            ctx[17]
          ),
          listen(
            button2,
            "click",
            /*click_handler_5*/
            ctx[18]
          ),
          listen(
            input,
            "change",
            /*change_handler_2*/
            ctx[19]
          ),
          listen(input, "focus", focus_handler_2)
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty &amp; /*slippageBps*/
      4 &amp;&amp; input_value_value !== (input_value_value = Number(
        /*slippageBps*/
        ctx2[2]
      ) / 100) &amp;&amp; input.value !== input_value_value) {
        input.value = input_value_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t3);
        detach(div1);
        detach(t9);
        detach(div2);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$4(ctx) {
  let div14;
  let div10;
  let div9;
  let div3;
  let div0;
  let t2;
  let div1;
  let span0;
  let t4;
  let span1;
  let t5_value = parseFloat(Number(ethers.formatUnits(
    /*gmtBalance*/
    ctx[5],
    decimalsLeft
  )).toFixed(4)) + "";
  let t5;
  let t6;
  let div2;
  let input0;
  let input0_title_value;
  let input0_value_value;
  let t7;
  let div4;
  let icon;
  let t8;
  let div8;
  let div5;
  let t11;
  let div6;
  let span2;
  let t13;
  let span3;
  let t14_value = parseFloat(Number(ethers.formatUnits(
    /*sutBalance*/
    ctx[6],
    decimalsRight
  )).toFixed(4)) + "";
  let t14;
  let t15;
  let div7;
  let input1;
  let input1_title_value;
  let input1_value_value;
  let t16;
  let div13;
  let div11;
  let span4;
  let t17;
  let t18_value = (!/*swapAmtLeft*/
  ctx[0] || !/*swapAmtRight*/
  ctx[1] || /*quoteLoading*/
  ctx[3] ? "?" : (parseFloat(Number(ethers.formatUnits(
    /*swapAmtLeft*/
    ctx[0],
    decimalsLeft
  )).toFixed(4)) / parseFloat(Number(ethers.formatUnits(
    /*swapAmtRight*/
    ctx[1],
    decimalsRight
  )).toFixed(4))).toFixed(4)) + "";
  let t18;
  let t19;
  let t20;
  let div12;
  let span5;
  let t22;
  let span6;
  let t23_value = Number(
    /*slippageBps*/
    ctx[2]
  ) / 100 + "";
  let t23;
  let t24;
  let t25;
  let t26;
  let actionbuttons;
  let t27;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  icon = new Icon({
    props: {
      data: ArrowSvg,
      width: "100%",
      height: "100%",
      stroke: "unset"
    }
  });
  let if_block0 = (
    /*swapAmtLeft*/
    ctx[0] &gt; /*gmtBalance*/
    ctx[5] &amp;&amp; create_if_block_1$1()
  );
  actionbuttons = new ActionButtons({
    props: {
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    }
  });
  let if_block1 = (
    /*settingsOpen*/
    ctx[4] &amp;&amp; create_if_block$2(ctx)
  );
  return {
    c() {
      div14 = element("div");
      div10 = element("div");
      div9 = element("div");
      div3 = element("div");
      div0 = element("div");
      div0.innerHTML = `&lt;img class="token-icon svelte-2n429h" alt="SUT" src="${GMTIcon}"/&gt; &lt;strong class="svelte-2n429h"&gt;GMT&lt;/strong&gt;`;
      t2 = space();
      div1 = element("div");
      span0 = element("span");
      span0.textContent = "Balance:";
      t4 = space();
      span1 = element("span");
      t5 = text(t5_value);
      t6 = space();
      div2 = element("div");
      input0 = element("input");
      t7 = space();
      div4 = element("div");
      create_component(icon.$$.fragment);
      t8 = space();
      div8 = element("div");
      div5 = element("div");
      div5.innerHTML = `&lt;img class="token-icon svelte-2n429h" alt="SUT" src="${SUTIcon}"/&gt; &lt;strong class="svelte-2n429h"&gt;SUT&lt;/strong&gt;`;
      t11 = space();
      div6 = element("div");
      span2 = element("span");
      span2.textContent = "Balance:";
      t13 = space();
      span3 = element("span");
      t14 = text(t14_value);
      t15 = space();
      div7 = element("div");
      input1 = element("input");
      t16 = space();
      div13 = element("div");
      div11 = element("div");
      span4 = element("span");
      t17 = text("1 SUT = ");
      t18 = text(t18_value);
      t19 = text(" GMT");
      t20 = space();
      div12 = element("div");
      span5 = element("span");
      span5.textContent = "Slippage:";
      t22 = space();
      span6 = element("span");
      t23 = text(t23_value);
      t24 = text("%");
      t25 = space();
      if (if_block0)
        if_block0.c();
      t26 = space();
      create_component(actionbuttons.$$.fragment);
      t27 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      attr(div0, "class", "token-header svelte-2n429h");
      attr(span0, "class", "label svelte-2n429h");
      attr(span1, "class", "balance svelte-2n429h");
      attr(div1, "class", "balance-box svelte-2n429h");
      attr(input0, "class", "amount-input svelte-2n429h");
      attr(input0, "type", "number");
      attr(input0, "title", input0_title_value = ethers.formatUnits(
        /*swapAmtLeft*/
        ctx[0],
        decimalsLeft
      ));
      input0.value = input0_value_value = parseFloat(Number(ethers.formatUnits(
        /*swapAmtLeft*/
        ctx[0],
        decimalsLeft
      )).toFixed(4));
      attr(div2, "class", "amount-box svelte-2n429h");
      attr(div3, "class", "swap-left svelte-2n429h");
      attr(div4, "class", "arrow-box svelte-2n429h");
      attr(div5, "class", "token-header svelte-2n429h");
      attr(span2, "class", "label svelte-2n429h");
      attr(span3, "class", "balance svelte-2n429h");
      attr(div6, "class", "balance-box svelte-2n429h");
      attr(input1, "class", "amount-input svelte-2n429h");
      attr(input1, "type", "number");
      attr(input1, "title", input1_title_value = ethers.formatUnits(
        /*swapAmtRight*/
        ctx[1],
        decimalsRight
      ));
      input1.value = input1_value_value = parseFloat(Number(ethers.formatUnits(
        /*swapAmtRight*/
        ctx[1],
        decimalsRight
      )).toFixed(4));
      attr(div7, "class", "amount-box svelte-2n429h");
      attr(div8, "class", "swap-right svelte-2n429h");
      attr(div9, "class", "swap-panel svelte-2n429h");
      attr(div10, "class", "row svelte-2n429h");
      attr(span4, "class", "label svelte-2n429h");
      attr(div11, "class", "balance-box svelte-2n429h");
      attr(span5, "class", "label svelte-2n429h");
      attr(span6, "class", "value svelte-2n429h");
      attr(div12, "class", "balance-box svelte-2n429h");
      set_style(div12, "margin-top", "4px");
      attr(div13, "class", "row svelte-2n429h");
      attr(div14, "class", "svelte-2n429h");
    },
    m(target, anchor) {
      insert(target, div14, anchor);
      append(div14, div10);
      append(div10, div9);
      append(div9, div3);
      append(div3, div0);
      append(div3, t2);
      append(div3, div1);
      append(div1, span0);
      append(div1, t4);
      append(div1, span1);
      append(span1, t5);
      append(div3, t6);
      append(div3, div2);
      append(div2, input0);
      append(div9, t7);
      append(div9, div4);
      mount_component(icon, div4, null);
      append(div9, t8);
      append(div9, div8);
      append(div8, div5);
      append(div8, t11);
      append(div8, div6);
      append(div6, span2);
      append(div6, t13);
      append(div6, span3);
      append(span3, t14);
      append(div8, t15);
      append(div8, div7);
      append(div7, input1);
      append(div14, t16);
      append(div14, div13);
      append(div13, div11);
      append(div11, span4);
      append(span4, t17);
      append(span4, t18);
      append(span4, t19);
      append(div13, t20);
      append(div13, div12);
      append(div12, span5);
      append(div12, t22);
      append(div12, span6);
      append(span6, t23);
      append(span6, t24);
      append(div13, t25);
      if (if_block0)
        if_block0.m(div13, null);
      append(div14, t26);
      mount_component(actionbuttons, div14, null);
      insert(target, t27, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*change_handler*/
            ctx[11]
          ),
          listen(input0, "focus", focus_handler$1),
          listen(
            input1,
            "change",
            /*change_handler_1*/
            ctx[12]
          ),
          listen(input1, "focus", focus_handler_1)
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty &amp; /*gmtBalance*/
      32) &amp;&amp; t5_value !== (t5_value = parseFloat(Number(ethers.formatUnits(
        /*gmtBalance*/
        ctx2[5],
        decimalsLeft
      )).toFixed(4)) + ""))
        set_data(t5, t5_value);
      if (!current || dirty &amp; /*swapAmtLeft*/
      1 &amp;&amp; input0_title_value !== (input0_title_value = ethers.formatUnits(
        /*swapAmtLeft*/
        ctx2[0],
        decimalsLeft
      ))) {
        attr(input0, "title", input0_title_value);
      }
      if (!current || dirty &amp; /*swapAmtLeft*/
      1 &amp;&amp; input0_value_value !== (input0_value_value = parseFloat(Number(ethers.formatUnits(
        /*swapAmtLeft*/
        ctx2[0],
        decimalsLeft
      )).toFixed(4))) &amp;&amp; input0.value !== input0_value_value) {
        input0.value = input0_value_value;
      }
      if ((!current || dirty &amp; /*sutBalance*/
      64) &amp;&amp; t14_value !== (t14_value = parseFloat(Number(ethers.formatUnits(
        /*sutBalance*/
        ctx2[6],
        decimalsRight
      )).toFixed(4)) + ""))
        set_data(t14, t14_value);
      if (!current || dirty &amp; /*swapAmtRight*/
      2 &amp;&amp; input1_title_value !== (input1_title_value = ethers.formatUnits(
        /*swapAmtRight*/
        ctx2[1],
        decimalsRight
      ))) {
        attr(input1, "title", input1_title_value);
      }
      if (!current || dirty &amp; /*swapAmtRight*/
      2 &amp;&amp; input1_value_value !== (input1_value_value = parseFloat(Number(ethers.formatUnits(
        /*swapAmtRight*/
        ctx2[1],
        decimalsRight
      )).toFixed(4))) &amp;&amp; input1.value !== input1_value_value) {
        input1.value = input1_value_value;
      }
      if ((!current || dirty &amp; /*swapAmtLeft, swapAmtRight, quoteLoading*/
      11) &amp;&amp; t18_value !== (t18_value = (!/*swapAmtLeft*/
      ctx2[0] || !/*swapAmtRight*/
      ctx2[1] || /*quoteLoading*/
      ctx2[3] ? "?" : (parseFloat(Number(ethers.formatUnits(
        /*swapAmtLeft*/
        ctx2[0],
        decimalsLeft
      )).toFixed(4)) / parseFloat(Number(ethers.formatUnits(
        /*swapAmtRight*/
        ctx2[1],
        decimalsRight
      )).toFixed(4))).toFixed(4)) + ""))
        set_data(t18, t18_value);
      if ((!current || dirty &amp; /*slippageBps*/
      4) &amp;&amp; t23_value !== (t23_value = Number(
        /*slippageBps*/
        ctx2[2]
      ) / 100 + ""))
        set_data(t23, t23_value);
      if (
        /*swapAmtLeft*/
        ctx2[0] &gt; /*gmtBalance*/
        ctx2[5]
      ) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_1$1();
          if_block0.c();
          if_block0.m(div13, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      const actionbuttons_changes = {};
      if (dirty &amp; /*$$scope, settingsOpen, swapAmtLeft, swapAmtRight, quoteLoading, gmtBalance*/
      268435515) {
        actionbuttons_changes.$$scope = { dirty, ctx: ctx2 };
      }
      actionbuttons.$set(actionbuttons_changes);
      if (
        /*settingsOpen*/
        ctx2[4]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty &amp; /*settingsOpen*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () =&gt; {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      transition_in(actionbuttons.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      transition_out(actionbuttons.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div14);
        detach(t27);
        detach(if_block1_anchor);
      }
      destroy_component(icon);
      if (if_block0)
        if_block0.d();
      destroy_component(actionbuttons);
      if (if_block1)
        if_block1.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
let decimalsLeft = 8n;
let decimalsRight = 18n;
const focus_handler$1 = (e) =&gt; e.target.select();
const focus_handler_1 = (e) =&gt; e.target.select();
const focus_handler_2 = (e) =&gt; e.target.select();
function instance$3($$self, $$props, $$invalidate) {
  const router = tokenscript.eth.getContractInstance("DooarSwapRouter");
  let { close } = $$props;
  let { ownerAddress } = $$props;
  let swapTokenLeft = tokenscript.eth.getContractInfo("GMTToken").address;
  let swapTokenRight = tokenscript.eth.getContractInfo("SUTToken").address;
  let swapAmtLeft = 0n;
  let swapAmtRight = 0n;
  let exactOutput = false;
  let slippageBps = 100n;
  let quoteLoading = false;
  let settingsOpen = false;
  let gmt;
  let gmtBalance = 0n;
  let sut;
  let sutBalance = 0n;
  onMount(async () =&gt; {
    gmt = tokenscript.eth.getContractInstance("GMTToken");
    $$invalidate(5, gmtBalance = await gmt.balanceOf(ownerAddress));
    sut = tokenscript.eth.getContractInstance("SUTToken");
    $$invalidate(6, sutBalance = await sut.balanceOf(ownerAddress));
  });
  async function updateSwapAmounts(left = true) {
    tokenscript.action.showLoader();
    $$invalidate(3, quoteLoading = true);
    try {
      if (left) {
        const amounts = await router.getAmountsOut(swapAmtLeft, [swapTokenLeft, swapTokenRight]);
        $$invalidate(1, swapAmtRight = amounts[1]);
        exactOutput = false;
      } else {
        const amounts = await router.getAmountsIn(swapAmtRight, [swapTokenLeft, swapTokenRight]);
        $$invalidate(0, swapAmtLeft = amounts[0]);
        exactOutput = true;
      }
    } catch (e) {
      console.error(e);
      tokenscript.action.showMessageToast("error", "Failed to load quote", e.message);
    }
    tokenscript.action.hideLoader();
    $$invalidate(3, quoteLoading = false);
  }
  async function swap() {
    await updateSwapAmounts(!exactOutput);
    tokenscript.action.showLoader();
    let inputs = getInputs();
    const allowance = await gmt.allowance(ownerAddress, router.target);
    if ((inputs.amountInMax ?? inputs.amountIn) &gt; allowance) {
      tokenscript.action.setProps({ approveAmt: swapAmtLeft });
      if (!await tokenscript.action.executeTransaction("approveGMTForSwap")) {
        return;
      }
      await updateSwapAmounts(!exactOutput);
    }
    inputs = getInputs();
    tokenscript.action.setProps(inputs);
    if (!await tokenscript.action.executeTransaction(exactOutput ? "swapTokensForExactTokens" : "swapExactTokensForTokens")) {
      return;
    }
    close();
  }
  function getInputs() {
    const inputs = {
      path: [swapTokenLeft, swapTokenRight],
      deadline: Math.floor(Date.now() / 1e3) + 60 * 20
    };
    if (exactOutput) {
      inputs.amountOut = swapAmtRight;
      inputs.amountInMax = swapAmtLeft + swapAmtLeft * slippageBps / 10000n;
    } else {
      inputs.amountIn = swapAmtLeft;
      inputs.amountOutMin = swapAmtRight - swapAmtRight * slippageBps / 10000n;
    }
    return inputs;
  }
  const change_handler = async (e) =&gt; {
    $$invalidate(0, swapAmtLeft = ethers.parseUnits(e.target.value, decimalsLeft));
    if (!swapAmtLeft) {
      $$invalidate(1, swapAmtRight = 0n);
      return;
    }
    await updateSwapAmounts(true);
  };
  const change_handler_1 = async (e) =&gt; {
    $$invalidate(1, swapAmtRight = ethers.parseUnits(e.target.value, decimalsRight));
    if (!swapAmtRight) {
      $$invalidate(0, swapAmtLeft = 0n);
      return;
    }
    await updateSwapAmounts(false);
  };
  const click_handler = () =&gt; swap();
  const click_handler_1 = () =&gt; $$invalidate(4, settingsOpen = true);
  const click_handler_2 = () =&gt; $$invalidate(4, settingsOpen = false);
  const click_handler_3 = () =&gt; $$invalidate(2, slippageBps = 50n);
  const click_handler_4 = () =&gt; $$invalidate(2, slippageBps = 100n);
  const click_handler_5 = () =&gt; $$invalidate(2, slippageBps = 500n);
  const change_handler_2 = async (e) =&gt; {
    $$invalidate(2, slippageBps = BigInt(Math.round(e.target.value * 100)));
  };
  const func2 = () =&gt; {
    $$invalidate(4, settingsOpen = false);
  };
  $$self.$$set = ($$props2) =&gt; {
    if ("close" in $$props2)
      $$invalidate(9, close = $$props2.close);
    if ("ownerAddress" in $$props2)
      $$invalidate(10, ownerAddress = $$props2.ownerAddress);
  };
  return [
    swapAmtLeft,
    swapAmtRight,
    slippageBps,
    quoteLoading,
    settingsOpen,
    gmtBalance,
    sutBalance,
    updateSwapAmounts,
    swap,
    close,
    ownerAddress,
    change_handler,
    change_handler_1,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    change_handler_2,
    func2
  ];
}
class DooarSwap extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3, create_fragment$4, safe_not_equal, { close: 9, ownerAddress: 10 });
  }
}
function create_if_block$1(ctx) {
  let div1;
  let div0;
  let h3;
  let t0_value = getCharacterName(
    /*token*/
    ctx[0]
  ) + "";
  let t0;
  let t1;
  let t2_value = (
    /*token*/
    ctx[0].morchiInfo.state.level + ""
  );
  let t2;
  let t3;
  let div2;
  let imageicon;
  let t4;
  let div3;
  let span;
  let t6;
  let strong;
  let t7_value = Number(ethers.formatEther(
    /*token*/
    ctx[0].morchiInfo.state.pointsBalance
  )).toFixed(2) + "";
  let t7;
  let t8;
  let div4;
  let actionbuttons;
  let t9;
  let t10;
  let t11;
  let t12;
  let t13;
  let t14;
  let if_block5_anchor;
  let current;
  imageicon = new ImageIcon({
    props: {
      src: (
        /*currentAnimation*/
        ctx[12] ?? /*token*/
        ctx[0].image_preview_url
      ),
      width: "100%"
    }
  });
  actionbuttons = new ActionButtons({
    props: {
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*bioOpen*/
    ctx[2] &amp;&amp; create_if_block_14(ctx)
  );
  let if_block1 = (
    /*levelUpOpen*/
    ctx[3] &amp;&amp; create_if_block_7(ctx)
  );
  let if_block2 = (
    /*successDialogOpen*/
    ctx[9] &amp;&amp; create_if_block_4(ctx)
  );
  let if_block3 = (
    /*redeemOpen*/
    ctx[6] &amp;&amp; create_if_block_3(ctx)
  );
  let if_block4 = (
    /*inviteCode*/
    ctx[7] &amp;&amp; create_if_block_2(ctx)
  );
  let if_block5 = (
    /*swapOpen*/
    ctx[8] &amp;&amp; create_if_block_1(ctx)
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      h3 = element("h3");
      t0 = text(t0_value);
      t1 = text(" - Level ");
      t2 = text(t2_value);
      t3 = space();
      div2 = element("div");
      create_component(imageicon.$$.fragment);
      t4 = space();
      div3 = element("div");
      span = element("span");
      span.textContent = "Points";
      t6 = space();
      strong = element("strong");
      t7 = text(t7_value);
      t8 = space();
      div4 = element("div");
      create_component(actionbuttons.$$.fragment);
      t9 = space();
      if (if_block0)
        if_block0.c();
      t10 = space();
      if (if_block1)
        if_block1.c();
      t11 = space();
      if (if_block2)
        if_block2.c();
      t12 = space();
      if (if_block3)
        if_block3.c();
      t13 = space();
      if (if_block4)
        if_block4.c();
      t14 = space();
      if (if_block5)
        if_block5.c();
      if_block5_anchor = empty();
      set_style(div0, "text-align", "center");
      attr(div1, "class", "row");
      attr(div2, "class", "row");
      set_style(strong, "flex-grow", "1");
      set_style(strong, "text-align", "right");
      attr(div3, "class", "row info-box");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, h3);
      append(h3, t0);
      append(h3, t1);
      append(h3, t2);
      insert(target, t3, anchor);
      insert(target, div2, anchor);
      mount_component(imageicon, div2, null);
      insert(target, t4, anchor);
      insert(target, div3, anchor);
      append(div3, span);
      append(div3, t6);
      append(div3, strong);
      append(strong, t7);
      insert(target, t8, anchor);
      insert(target, div4, anchor);
      mount_component(actionbuttons, div4, null);
      insert(target, t9, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t10, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t11, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, t12, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert(target, t13, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert(target, t14, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert(target, if_block5_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] &amp; /*token*/
      1) &amp;&amp; t0_value !== (t0_value = getCharacterName(
        /*token*/
        ctx2[0]
      ) + ""))
        set_data(t0, t0_value);
      if ((!current || dirty[0] &amp; /*token*/
      1) &amp;&amp; t2_value !== (t2_value = /*token*/
      ctx2[0].morchiInfo.state.level + ""))
        set_data(t2, t2_value);
      const imageicon_changes = {};
      if (dirty[0] &amp; /*currentAnimation, token*/
      4097)
        imageicon_changes.src = /*currentAnimation*/
        ctx2[12] ?? /*token*/
        ctx2[0].image_preview_url;
      imageicon.$set(imageicon_changes);
      if ((!current || dirty[0] &amp; /*token*/
      1) &amp;&amp; t7_value !== (t7_value = Number(ethers.formatEther(
        /*token*/
        ctx2[0].morchiInfo.state.pointsBalance
      )).toFixed(2) + ""))
        set_data(t7, t7_value);
      const actionbuttons_changes = {};
      if (dirty[0] &amp; /*token, cannotInvite, bioOpen*/
      8197 | dirty[1] &amp; /*$$scope*/
      128) {
        actionbuttons_changes.$$scope = { dirty, ctx: ctx2 };
      }
      actionbuttons.$set(actionbuttons_changes);
      if (
        /*bioOpen*/
        ctx2[2]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] &amp; /*bioOpen*/
          4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_14(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t10.parentNode, t10);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () =&gt; {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*levelUpOpen*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] &amp; /*levelUpOpen*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_7(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t11.parentNode, t11);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () =&gt; {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*successDialogOpen*/
        ctx2[9]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] &amp; /*successDialogOpen*/
          512) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_4(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t12.parentNode, t12);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () =&gt; {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*redeemOpen*/
        ctx2[6]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] &amp; /*redeemOpen*/
          64) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_3(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t13.parentNode, t13);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () =&gt; {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*inviteCode*/
        ctx2[7]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] &amp; /*inviteCode*/
          128) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_2(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t14.parentNode, t14);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () =&gt; {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*swapOpen*/
        ctx2[8]
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] &amp; /*swapOpen*/
          256) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_1(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () =&gt; {
          if_block5 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(imageicon.$$.fragment, local);
      transition_in(actionbuttons.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      current = true;
    },
    o(local) {
      transition_out(imageicon.$$.fragment, local);
      transition_out(actionbuttons.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t3);
        detach(div2);
        detach(t4);
        detach(div3);
        detach(t8);
        detach(div4);
        detach(t9);
        detach(t10);
        detach(t11);
        detach(t12);
        detach(t13);
        detach(t14);
        detach(if_block5_anchor);
      }
      destroy_component(imageicon);
      destroy_component(actionbuttons);
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
      if (if_block3)
        if_block3.d(detaching);
      if (if_block4)
        if_block4.d(detaching);
      if (if_block5)
        if_block5.d(detaching);
    }
  };
}
function create_if_block_15(ctx) {
  let button0;
  let span0;
  let button0_disabled_value;
  let t1;
  let button1;
  let span1;
  let button1_disabled_value;
  let t3;
  let button2;
  let span2;
  let button2_disabled_value;
  let t5;
  let show_if = Number(
    /*token*/
    ctx[0].tokenId
  ) &lt;= 9999;
  let t6;
  let div;
  let t7;
  let a;
  let current;
  let mounted;
  let dispose;
  let if_block0 = show_if &amp;&amp; create_if_block_17(ctx);
  let if_block1 = (!/*token*/
  ctx[0].morchiInfo.canDrink || !/*token*/
  ctx[0].morchiInfo.canShower || !/*token*/
  ctx[0].morchiInfo.canWorkOut) &amp;&amp; create_if_block_16(ctx);
  return {
    c() {
      button0 = element("button");
      span0 = element("span");
      span0.textContent = "Chug Energy Drink";
      t1 = space();
      button1 = element("button");
      span1 = element("span");
      span1.textContent = "Cold Shower";
      t3 = space();
      button2 = element("button");
      span2 = element("span");
      span2.textContent = "Gym Grind";
      t5 = space();
      if (if_block0)
        if_block0.c();
      t6 = space();
      div = element("div");
      if (if_block1)
        if_block1.c();
      t7 = space();
      a = element("a");
      a.innerHTML = `&lt;h4 class="task-hint-text" style="margin-top: 15px;"&gt;How To Play&lt;/h4&gt;`;
      attr(button0, "class", "btn btn-secondary");
      button0.disabled = button0_disabled_value = !/*token*/
      ctx[0].morchiInfo.canDrink;
      attr(button1, "class", "btn btn-secondary");
      button1.disabled = button1_disabled_value = !/*token*/
      ctx[0].morchiInfo.canShower;
      attr(button2, "class", "btn btn-secondary");
      button2.disabled = button2_disabled_value = !/*token*/
      ctx[0].morchiInfo.canWorkOut;
      set_style(a, "text-decoration", "none");
      attr(a, "href", "https://fsl-web3.notion.site/MORCHI-4f61e632a6ce4b9e80d2bcfa344f0e6a");
      attr(a, "target", "_blank");
      set_style(div, "height", "50px");
      set_style(div, "width", "100%");
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      append(button0, span0);
      insert(target, t1, anchor);
      insert(target, button1, anchor);
      append(button1, span1);
      insert(target, t3, anchor);
      insert(target, button2, anchor);
      append(button2, span2);
      insert(target, t5, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t6, anchor);
      insert(target, div, anchor);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t7);
      append(div, a);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler_1*/
            ctx[17]
          ),
          listen(
            button1,
            "click",
            /*click_handler_2*/
            ctx[18]
          ),
          listen(
            button2,
            "click",
            /*click_handler_3*/
            ctx[19]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] &amp; /*token*/
      1 &amp;&amp; button0_disabled_value !== (button0_disabled_value = !/*token*/
      ctx2[0].morchiInfo.canDrink)) {
        button0.disabled = button0_disabled_value;
      }
      if (!current || dirty[0] &amp; /*token*/
      1 &amp;&amp; button1_disabled_value !== (button1_disabled_value = !/*token*/
      ctx2[0].morchiInfo.canShower)) {
        button1.disabled = button1_disabled_value;
      }
      if (!current || dirty[0] &amp; /*token*/
      1 &amp;&amp; button2_disabled_value !== (button2_disabled_value = !/*token*/
      ctx2[0].morchiInfo.canWorkOut)) {
        button2.disabled = button2_disabled_value;
      }
      if (dirty[0] &amp; /*token*/
      1)
        show_if = Number(
          /*token*/
          ctx2[0].tokenId
        ) &lt;= 9999;
      if (show_if) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_17(ctx2);
          if_block0.c();
          if_block0.m(t6.parentNode, t6);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!/*token*/
      ctx2[0].morchiInfo.canDrink || !/*token*/
      ctx2[0].morchiInfo.canShower || !/*token*/
      ctx2[0].morchiInfo.canWorkOut) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] &amp; /*token*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_16(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t7);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () =&gt; {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t1);
        detach(button1);
        detach(t3);
        detach(button2);
        detach(t5);
        detach(t6);
        detach(div);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_17(ctx) {
  let button;
  let span;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      span = element("span");
      span.textContent = "Create Invite Code";
      attr(button, "class", "btn btn-secondary");
      button.disabled = /*cannotInvite*/
      ctx[13];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_4*/
          ctx[20]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] &amp; /*cannotInvite*/
      8192) {
        button.disabled = /*cannotInvite*/
        ctx2[13];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_16(ctx) {
  let countdowntimer;
  let current;
  countdowntimer = new CountdownTimer({
    props: {
      epochMs: (Number(
        /*token*/
        ctx[0].morchiInfo.state.firstTaskTime
      ) + 86400) * 1e3
    }
  });
  return {
    c() {
      create_component(countdowntimer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(countdowntimer, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const countdowntimer_changes = {};
      if (dirty[0] &amp; /*token*/
      1)
        countdowntimer_changes.epochMs = (Number(
          /*token*/
          ctx2[0].morchiInfo.state.firstTaskTime
        ) + 86400) * 1e3;
      countdowntimer.$set(countdowntimer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(countdowntimer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(countdowntimer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(countdowntimer, detaching);
    }
  };
}
function create_default_slot_7(ctx) {
  let button;
  let span;
  let t0_value = getCharacterName(
    /*token*/
    ctx[0]
  ) + "";
  let t0;
  let t1;
  let t2;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*token*/
    ctx[0].morchiInfo.state.level &lt; 30 &amp;&amp; create_if_block_15(ctx)
  );
  return {
    c() {
      button = element("button");
      span = element("span");
      t0 = text(t0_value);
      t1 = text("'s BIO");
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(button, "class", "btn btn-primary");
      set_style(button, "flex", "100%");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span);
      append(span, t0);
      append(span, t1);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[16]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] &amp; /*token*/
      1) &amp;&amp; t0_value !== (t0_value = getCharacterName(
        /*token*/
        ctx2[0]
      ) + ""))
        set_data(t0, t0_value);
      if (
        /*token*/
        ctx2[0].morchiInfo.state.level &lt; 30
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] &amp; /*token*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_15(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () =&gt; {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
        detach(t2);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_14(ctx) {
  let popovermodal;
  let current;
  popovermodal = new PopoverModal({
    props: {
      title: getCharacterName(
        /*token*/
        ctx[0]
      ) + "'s Bio",
      dismissCallback: (
        /*func_2*/
        ctx[23]
      ),
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popovermodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popovermodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const popovermodal_changes = {};
      if (dirty[0] &amp; /*token*/
      1)
        popovermodal_changes.title = getCharacterName(
          /*token*/
          ctx2[0]
        ) + "'s Bio";
      if (dirty[0] &amp; /*bioOpen*/
      4)
        popovermodal_changes.dismissCallback = /*func_2*/
        ctx2[23];
      if (dirty[0] &amp; /*token, levelUpOpen, redeemOpen*/
      73 | dirty[1] &amp; /*$$scope*/
      128) {
        popovermodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popovermodal.$set(popovermodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(popovermodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popovermodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popovermodal, detaching);
    }
  };
}
function create_default_slot_6(ctx) {
  let biocard;
  let current;
  biocard = new BioCard({
    props: {
      token: (
        /*token*/
        ctx[0]
      ),
      openLevelUp: (
        /*func*/
        ctx[21]
      ),
      openRedeem: (
        /*func_1*/
        ctx[22]
      )
    }
  });
  return {
    c() {
      create_component(biocard.$$.fragment);
    },
    m(target, anchor) {
      mount_component(biocard, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const biocard_changes = {};
      if (dirty[0] &amp; /*token*/
      1)
        biocard_changes.token = /*token*/
        ctx2[0];
      if (dirty[0] &amp; /*levelUpOpen*/
      8)
        biocard_changes.openLevelUp = /*func*/
        ctx2[21];
      if (dirty[0] &amp; /*redeemOpen*/
      64)
        biocard_changes.openRedeem = /*func_1*/
        ctx2[22];
      biocard.$set(biocard_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(biocard.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(biocard.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(biocard, detaching);
    }
  };
}
function create_if_block_7(ctx) {
  let popovermodal;
  let current;
  popovermodal = new PopoverModal({
    props: {
      title: (
        /*levelUpSuccess*/
        ctx[4] ? "Congratulations!" : (
          /*token*/
          ctx[0].morchiInfo.state.level == 29 ? "Final Upgrade" : "Level Up Costs"
        )
      ),
      dismissCallback: (
        /*func_5*/
        ctx[28]
      ),
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popovermodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popovermodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const popovermodal_changes = {};
      if (dirty[0] &amp; /*levelUpSuccess, token*/
      17)
        popovermodal_changes.title = /*levelUpSuccess*/
        ctx2[4] ? "Congratulations!" : (
          /*token*/
          ctx2[0].morchiInfo.state.level == 29 ? "Final Upgrade" : "Level Up Costs"
        );
      if (dirty[0] &amp; /*levelUpOpen, levelUpSuccess*/
      24)
        popovermodal_changes.dismissCallback = /*func_5*/
        ctx2[28];
      if (dirty[0] &amp; /*gameFinished, levelUpOpen, levelUpSuccess, bioOpen, cannotInvite, token, swapOpen*/
      8509 | dirty[1] &amp; /*$$scope*/
      128) {
        popovermodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popovermodal.$set(popovermodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(popovermodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popovermodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popovermodal, detaching);
    }
  };
}
function create_else_block_3(ctx) {
  let levelupcard;
  let current;
  levelupcard = new LevelUpCard({
    props: {
      token: (
        /*token*/
        ctx[0]
      ),
      levelUpCallback: (
        /*func_3*/
        ctx[26]
      ),
      openSwap: (
        /*func_4*/
        ctx[27]
      )
    }
  });
  return {
    c() {
      create_component(levelupcard.$$.fragment);
    },
    m(target, anchor) {
      mount_component(levelupcard, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const levelupcard_changes = {};
      if (dirty[0] &amp; /*token*/
      1)
        levelupcard_changes.token = /*token*/
        ctx2[0];
      if (dirty[0] &amp; /*gameFinished, levelUpSuccess*/
      48)
        levelupcard_changes.levelUpCallback = /*func_3*/
        ctx2[26];
      if (dirty[0] &amp; /*levelUpOpen, swapOpen*/
      264)
        levelupcard_changes.openSwap = /*func_4*/
        ctx2[27];
      levelupcard.$set(levelupcard_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(levelupcard.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(levelupcard.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(levelupcard, detaching);
    }
  };
}
function create_if_block_8(ctx) {
  let div1;
  let t0;
  let video;
  let video_loop_value;
  let video_src_value;
  let t1;
  let div0;
  let t2;
  let actionbuttons;
  let current;
  let if_block0 = !/*gameFinished*/
  ctx[5] &amp;&amp; create_if_block_13();
  function select_block_type_1(ctx2, dirty) {
    if (
      /*gameFinished*/
      ctx2[5]
    )
      return create_if_block_11;
    return create_else_block_2;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block1 = current_block_type(ctx);
  actionbuttons = new ActionButtons({
    props: {
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      video = element("video");
      t1 = space();
      div0 = element("div");
      if_block1.c();
      t2 = space();
      create_component(actionbuttons.$$.fragment);
      video.autoplay = true;
      video.loop = video_loop_value = /*gameFinished*/
      ctx[5] ? "loop" : "";
      if (!src_url_equal(video.src, video_src_value = `${ASSETS_URL}level-up${/*gameFinished*/
      ctx[5] ? "-final" : ""}.mp4`))
        attr(video, "src", video_src_value);
      set_style(video, "width", "100%");
      set_style(video, "margin", "0 auto");
      attr(div0, "class", "info-box");
      set_style(div0, "display", "flex");
      set_style(div0, "flex-direction", "column");
      set_style(div1, "display", "flex");
      set_style(div1, "flex-direction", "column");
      set_style(div1, "gap", "20px");
      set_style(div1, "margin", "0 10px");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t0);
      append(div1, video);
      append(div1, t1);
      append(div1, div0);
      if_block1.m(div0, null);
      insert(target, t2, anchor);
      mount_component(actionbuttons, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!/*gameFinished*/
      ctx2[5]) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_13();
          if_block0.c();
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!current || dirty[0] &amp; /*gameFinished*/
      32 &amp;&amp; video_loop_value !== (video_loop_value = /*gameFinished*/
      ctx2[5] ? "loop" : "")) {
        video.loop = video_loop_value;
      }
      if (!current || dirty[0] &amp; /*gameFinished*/
      32 &amp;&amp; !src_url_equal(video.src, video_src_value = `${ASSETS_URL}level-up${/*gameFinished*/
      ctx2[5] ? "-final" : ""}.mp4`)) {
        attr(video, "src", video_src_value);
      }
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) &amp;&amp; if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div0, null);
        }
      }
      const actionbuttons_changes = {};
      if (dirty[0] &amp; /*gameFinished, levelUpOpen, levelUpSuccess, bioOpen, cannotInvite*/
      8252 | dirty[1] &amp; /*$$scope*/
      128) {
        actionbuttons_changes.$$scope = { dirty, ctx: ctx2 };
      }
      actionbuttons.$set(actionbuttons_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(actionbuttons.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actionbuttons.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t2);
      }
      if (if_block0)
        if_block0.d();
      if_block1.d();
      destroy_component(actionbuttons, detaching);
    }
  };
}
function create_if_block_13(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "You have just leveled up! ";
      set_style(p, "margin-bottom", "0");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_else_block_2(ctx) {
  let h2;
  let t0;
  let t1_value = (
    /*token*/
    ctx[0].morchiInfo.state.level + ""
  );
  let t1;
  let t2;
  let if_block_anchor;
  let if_block = (
    /*token*/
    ctx[0].morchiInfo.state.level &lt; 10n &amp;&amp; create_if_block_12()
  );
  return {
    c() {
      h2 = element("h2");
      t0 = text("Lv. ");
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      insert(target, h2, anchor);
      append(h2, t0);
      append(h2, t1);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] &amp; /*token*/
      1 &amp;&amp; t1_value !== (t1_value = /*token*/
      ctx2[0].morchiInfo.state.level + ""))
        set_data(t1, t1_value);
      if (
        /*token*/
        ctx2[0].morchiInfo.state.level &lt; 10n
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_12();
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(h2);
        detach(t2);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_11(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.innerHTML = `You have just completed the final upgrade! Please go to
								&lt;a target="_blank" style="color: #D4D3D3;" href="https://www.mooar.com/box/morchi"&gt;https://www.mooar.com/box/morchi&lt;/a&gt; to receive your MORCHI Achievement NFTs.
								The MOOAR Box drop might take a few minutes.`;
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block_12(ctx) {
  let hr;
  let t0;
  let p;
  return {
    c() {
      hr = element("hr");
      t0 = space();
      p = element("p");
      p.textContent = "You will increase your earnings by 2 times when you reach level 10.";
      set_style(hr, "width", "100%");
      set_style(hr, "color", "#46413F");
    },
    m(target, anchor) {
      insert(target, hr, anchor);
      insert(target, t0, anchor);
      insert(target, p, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(hr);
        detach(t0);
        detach(p);
      }
    }
  };
}
function create_else_block_1(ctx) {
  let button;
  let span;
  let button_class_value;
  let t1;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = !/*cannotInvite*/
  ctx[13] &amp;&amp; create_if_block_10(ctx);
  return {
    c() {
      button = element("button");
      span = element("span");
      span.textContent = "Sweet!";
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(button, "class", button_class_value = "btn " + /*cannotInvite*/
      (ctx[13] ? "btn-primary" : "btn-secondary"));
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_5*/
          ctx[24]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] &amp; /*cannotInvite*/
      8192 &amp;&amp; button_class_value !== (button_class_value = "btn " + /*cannotInvite*/
      (ctx2[13] ? "btn-primary" : "btn-secondary"))) {
        attr(button, "class", button_class_value);
      }
      if (!/*cannotInvite*/
      ctx2[13]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_10(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
        detach(t1);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_9(ctx) {
  let a;
  return {
    c() {
      a = element("a");
      a.innerHTML = `&lt;button class="btn btn-primary" style="width: 100%"&gt;&lt;span&gt;Go to MOOAR&lt;/span&gt;&lt;/button&gt;`;
      attr(a, "href", "https://www.mooar.com/box/morchi");
      attr(a, "target", "_blank");
      set_style(a, "flex-grow", "1");
    },
    m(target, anchor) {
      insert(target, a, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(a);
      }
    }
  };
}
function create_if_block_10(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `&lt;span&gt;Create Invite Code&lt;/span&gt;`;
      attr(button, "class", "btn btn-primary");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_6*/
          ctx[25]
        );
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_5(ctx) {
  let if_block_anchor;
  function select_block_type_2(ctx2, dirty) {
    if (
      /*gameFinished*/
      ctx2[5]
    )
      return create_if_block_9;
    return create_else_block_1;
  }
  let current_block_type = select_block_type_2(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_2(ctx2)) &amp;&amp; if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_default_slot_4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_8, create_else_block_3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*levelUpSuccess*/
      ctx2[4]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () =&gt; {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block_4(ctx) {
  let popovermodal;
  let current;
  popovermodal = new PopoverModal({
    props: {
      title: (
        /*pointsEarned*/
        ctx[10] &gt; 0 ? "Points Dropped!" : "Task Complete "
      ),
      dismissCallback: (
        /*func_6*/
        ctx[30]
      ),
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popovermodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popovermodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const popovermodal_changes = {};
      if (dirty[0] &amp; /*pointsEarned*/
      1024)
        popovermodal_changes.title = /*pointsEarned*/
        ctx2[10] &gt; 0 ? "Points Dropped!" : "Task Complete ";
      if (dirty[0] &amp; /*successDialogOpen*/
      512)
        popovermodal_changes.dismissCallback = /*func_6*/
        ctx2[30];
      if (dirty[0] &amp; /*successDialogOpen, pointsEarned, currentAction*/
      3584 | dirty[1] &amp; /*$$scope*/
      128) {
        popovermodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popovermodal.$set(popovermodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(popovermodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popovermodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popovermodal, detaching);
    }
  };
}
function create_else_block(ctx) {
  let t;
  return {
    c() {
      t = text("Power up complete! Youre unstoppable!  Continue to finish the rest of the daily task to win points!");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_6(ctx) {
  let t;
  return {
    c() {
      t = text("Congrats  Youve finished all daily tasks, and earned some points! MORCHI level up is enabled in the BIO.");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_5(ctx) {
  let div;
  let img;
  let img_src_value;
  let strong;
  let t0_value = (
    /*pointsEarned*/
    (ctx[10] !== null ? Number(ethers.formatEther(
      /*pointsEarned*/
      ctx[10]
    )).toFixed(2) : "-") + ""
  );
  let t0;
  let t1;
  return {
    c() {
      div = element("div");
      img = element("img");
      strong = element("strong");
      t0 = text(t0_value);
      t1 = text(" Points Earned! ");
      attr(img, "alt", "SUT");
      if (!src_url_equal(img.src, img_src_value = SUTIcon))
        attr(img, "src", img_src_value);
      set_style(img, "width", "35px");
      set_style(img, "height", "auto");
      set_style(img, "margin-right", "15px");
      attr(div, "class", "info-box gradient-border");
      set_style(div, "display", "flex");
      set_style(div, "flex-direction", "row");
      set_style(div, "padding", "15px 20px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
      append(div, strong);
      append(strong, t0);
      append(strong, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] &amp; /*pointsEarned*/
      1024 &amp;&amp; t0_value !== (t0_value = /*pointsEarned*/
      (ctx2[10] !== null ? Number(ethers.formatEther(
        /*pointsEarned*/
        ctx2[10]
      )).toFixed(2) : "-") + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_default_slot_3(ctx) {
  let div;
  let p;
  let t0;
  let imageicon;
  let t1;
  let t2;
  let button;
  let current;
  let mounted;
  let dispose;
  function select_block_type_3(ctx2, dirty) {
    if (
      /*pointsEarned*/
      ctx2[10] &gt; 0
    )
      return create_if_block_6;
    return create_else_block;
  }
  let current_block_type = select_block_type_3(ctx);
  let if_block0 = current_block_type(ctx);
  imageicon = new ImageIcon({
    props: {
      src: `${ASSETS_URL}${/*currentAction*/
      ctx[11]}_success.png`,
      width: "100%",
      maxWidth: "450px"
    }
  });
  let if_block1 = (
    /*pointsEarned*/
    ctx[10] &gt; 0 &amp;&amp; create_if_block_5(ctx)
  );
  return {
    c() {
      div = element("div");
      p = element("p");
      if_block0.c();
      t0 = space();
      create_component(imageicon.$$.fragment);
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      button = element("button");
      button.textContent = "Awesome!";
      set_style(p, "margin-bottom", "0");
      attr(button, "class", "btn btn-primary");
      set_style(div, "display", "flex");
      set_style(div, "flex-direction", "column");
      set_style(div, "gap", "20px");
      set_style(div, "margin", "0 10px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p);
      if_block0.m(p, null);
      append(div, t0);
      mount_component(imageicon, div, null);
      append(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t2);
      append(div, button);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_7*/
          ctx[29]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (current_block_type !== (current_block_type = select_block_type_3(ctx2))) {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(p, null);
        }
      }
      const imageicon_changes = {};
      if (dirty[0] &amp; /*currentAction*/
      2048)
        imageicon_changes.src = `${ASSETS_URL}${/*currentAction*/
        ctx2[11]}_success.png`;
      imageicon.$set(imageicon_changes);
      if (
        /*pointsEarned*/
        ctx2[10] &gt; 0
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_5(ctx2);
          if_block1.c();
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(imageicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(imageicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_block0.d();
      destroy_component(imageicon);
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3(ctx) {
  let popovermodal;
  let current;
  popovermodal = new PopoverModal({
    props: {
      title: "Token redemption",
      dismissCallback: (
        /*func_8*/
        ctx[32]
      ),
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popovermodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popovermodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const popovermodal_changes = {};
      if (dirty[0] &amp; /*redeemOpen*/
      64)
        popovermodal_changes.dismissCallback = /*func_8*/
        ctx2[32];
      if (dirty[0] &amp; /*token, redeemOpen*/
      65 | dirty[1] &amp; /*$$scope*/
      128) {
        popovermodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popovermodal.$set(popovermodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(popovermodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popovermodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popovermodal, detaching);
    }
  };
}
function create_default_slot_2(ctx) {
  let redeemcard;
  let current;
  redeemcard = new RedeemCard({
    props: {
      token: (
        /*token*/
        ctx[0]
      ),
      redeemedCallback: (
        /*func_7*/
        ctx[31]
      )
    }
  });
  return {
    c() {
      create_component(redeemcard.$$.fragment);
    },
    m(target, anchor) {
      mount_component(redeemcard, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const redeemcard_changes = {};
      if (dirty[0] &amp; /*token*/
      1)
        redeemcard_changes.token = /*token*/
        ctx2[0];
      if (dirty[0] &amp; /*redeemOpen*/
      64)
        redeemcard_changes.redeemedCallback = /*func_7*/
        ctx2[31];
      redeemcard.$set(redeemcard_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(redeemcard.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(redeemcard.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(redeemcard, detaching);
    }
  };
}
function create_if_block_2(ctx) {
  let popovermodal;
  let current;
  popovermodal = new PopoverModal({
    props: {
      title: "Invite code",
      dismissCallback: (
        /*func_9*/
        ctx[34]
      ),
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popovermodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popovermodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const popovermodal_changes = {};
      if (dirty[0] &amp; /*inviteCode*/
      128)
        popovermodal_changes.dismissCallback = /*func_9*/
        ctx2[34];
      if (dirty[0] &amp; /*inviteCode*/
      128 | dirty[1] &amp; /*$$scope*/
      128) {
        popovermodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popovermodal.$set(popovermodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(popovermodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popovermodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popovermodal, detaching);
    }
  };
}
function create_default_slot_1(ctx) {
  let div1;
  let p;
  let t1;
  let imageicon;
  let t2;
  let div0;
  let textarea;
  let textarea_value_value;
  let t3;
  let button;
  let current;
  let mounted;
  let dispose;
  imageicon = new ImageIcon({
    props: {
      src: `${ASSETS_URL}phone_success.png`,
      width: "100%",
      maxWidth: "450px"
    }
  });
  return {
    c() {
      div1 = element("div");
      p = element("p");
      p.textContent = "Congrats!  You've generated an activation code. Invite your friend to mint a free MORCHI NFT using the link below";
      t1 = space();
      create_component(imageicon.$$.fragment);
      t2 = space();
      div0 = element("div");
      textarea = element("textarea");
      t3 = space();
      button = element("button");
      button.textContent = "Copy";
      set_style(p, "margin-bottom", "0");
      set_style(textarea, "width", "100%");
      set_style(textarea, "padding", "10px");
      attr(textarea, "rows", "5");
      textarea.readOnly = true;
      textarea.value = textarea_value_value = `${ACTIVATION_URL}?inviteCode=${/*inviteCode*/
      ctx[7]}`;
      attr(button, "class", "btn btn-primary");
      set_style(button, "width", "100%");
      attr(div0, "class", "info-box");
      set_style(div0, "display", "flex");
      set_style(div0, "flex-direction", "column");
      set_style(div0, "padding", "15px 20px");
      set_style(div0, "gap", "15px");
      set_style(div1, "display", "flex");
      set_style(div1, "flex-direction", "column");
      set_style(div1, "gap", "20px");
      set_style(div1, "margin", "0 10px");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, p);
      append(div1, t1);
      mount_component(imageicon, div1, null);
      append(div1, t2);
      append(div1, div0);
      append(div0, textarea);
      append(div0, t3);
      append(div0, button);
      current = true;
      if (!mounted) {
        dispose = [
          listen(textarea, "focus", focus_handler),
          listen(
            button,
            "click",
            /*click_handler_8*/
            ctx[33]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] &amp; /*inviteCode*/
      128 &amp;&amp; textarea_value_value !== (textarea_value_value = `${ACTIVATION_URL}?inviteCode=${/*inviteCode*/
      ctx2[7]}`)) {
        textarea.value = textarea_value_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(imageicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(imageicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(imageicon);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1(ctx) {
  let popovermodal;
  let current;
  popovermodal = new PopoverModal({
    props: {
      title: "Swap with DOOAR",
      dismissCallback: (
        /*func_11*/
        ctx[36]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popovermodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popovermodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const popovermodal_changes = {};
      if (dirty[0] &amp; /*swapOpen, levelUpOpen*/
      264)
        popovermodal_changes.dismissCallback = /*func_11*/
        ctx2[36];
      if (dirty[0] &amp; /*token, swapOpen, levelUpOpen*/
      265 | dirty[1] &amp; /*$$scope*/
      128) {
        popovermodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popovermodal.$set(popovermodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(popovermodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popovermodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popovermodal, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let dooarswap;
  let current;
  dooarswap = new DooarSwap({
    props: {
      ownerAddress: (
        /*token*/
        ctx[0].ownerAddress
      ),
      close: (
        /*func_10*/
        ctx[35]
      )
    }
  });
  return {
    c() {
      create_component(dooarswap.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dooarswap, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dooarswap_changes = {};
      if (dirty[0] &amp; /*token*/
      1)
        dooarswap_changes.ownerAddress = /*token*/
        ctx2[0].ownerAddress;
      if (dirty[0] &amp; /*swapOpen, levelUpOpen*/
      264)
        dooarswap_changes.close = /*func_10*/
        ctx2[35];
      dooarswap.$set(dooarswap_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dooarswap.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dooarswap.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dooarswap, detaching);
    }
  };
}
function create_fragment$3(ctx) {
  let t;
  let loader;
  let current;
  let if_block = (
    /*token*/
    ctx[0] &amp;&amp; create_if_block$1(ctx)
  );
  loader = new Loader({ props: { show: (
    /*loading*/
    ctx[1]
  ) } });
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      mount_component(loader, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*token*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] &amp; /*token*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () =&gt; {
          if_block = null;
        });
        check_outros();
      }
      const loader_changes = {};
      if (dirty[0] &amp; /*loading*/
      2)
        loader_changes.show = /*loading*/
        ctx2[1];
      loader.$set(loader_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      if (if_block)
        if_block.d(detaching);
      destroy_component(loader, detaching);
    }
  };
}
async function base64URLEncode(array) {
  const base64Encoded = await bufferToBase64(array);
  return base64Encoded.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
async function bufferToBase64(buffer) {
  const base64url = await new Promise((r) =&gt; {
    const reader = new FileReader();
    reader.onload = () =&gt; r(reader.result);
    reader.readAsDataURL(new Blob([buffer]));
  });
  return base64url.slice(base64url.indexOf(",") + 1);
}
const focus_handler = (e) =&gt; e.target.select();
function instance$2($$self, $$props, $$invalidate) {
  let cannotInvite;
  let token;
  let loading = true;
  let bioOpen = false;
  let levelUpOpen = false;
  let levelUpSuccess = false;
  let gameFinished = false;
  let redeemOpen = false;
  let inviteCode = false;
  let swapOpen = false;
  let successDialogOpen = false;
  let pointsEarned = 0n;
  let currentAction = null;
  let currentAnimation = null;
  context.data.subscribe(async (value) =&gt; {
    if (!value.token)
      return;
    $$invalidate(0, token = value.token);
    $$invalidate(1, loading = false);
  });
  async function performPointsActivity(activity) {
    try {
      setAnimation(activity);
      if (await tokenscript.action.executeTransaction(activity)) {
        const state = token.morchiInfo.state;
        if ((state.hasDrunk ? 1 : 0) + (state.hasShowered ? 1 : 0) + (state.hasWorkedOut ? 1 : 0) == 3) {
          $$invalidate(10, pointsEarned = await tokenscript.eth.getContractInstance("MorchiScore").TASK_POINTS(BigInt(Math.max(Number(state.level) - 1, 0))));
        } else {
          $$invalidate(10, pointsEarned = 0n);
        }
        $$invalidate(9, successDialogOpen = true);
      }
    } catch (e) {
      console.error(e);
    }
    $$invalidate(12, currentAnimation = null);
  }
  function setAnimation(activity) {
    let filename;
    switch (activity) {
      case "chugEnergyDrink":
        filename = "drink";
        break;
      case "haveAColdShower":
        filename = "shower";
        break;
      case "inviteFriend":
        filename = "phone";
        break;
      case "grindAtTheGym":
        filename = "gym";
        break;
      default:
        $$invalidate(12, currentAnimation = null);
        $$invalidate(11, currentAction = null);
        return;
    }
    $$invalidate(11, currentAction = filename);
    $$invalidate(12, currentAnimation = ASSETS_URL + filename + ".gif");
  }
  async function getInviteCode() {
    try {
      setAnimation("inviteFriend");
      const levelToIssueActivationCode = BigInt(token.gameLevelActivationCodeUsed) + BigInt(5);
      const data2 = ethers.AbiCoder.defaultAbiCoder().encode(["address", "uint", "uint", "uint8"], [
        token.contractAddress,
        BigInt(token.chainId),
        BigInt(token.tokenId),
        levelToIssueActivationCode
      ]);
      const signature = await tokenscript.personal.sign({
        data: ethers.getBytes(ethers.keccak256(data2))
      });
      const code = ethers.AbiCoder.defaultAbiCoder().encode(["uint", "uint8", "bytes"], [BigInt(token.tokenId), levelToIssueActivationCode, signature]);
      console.log("code: ", code);
      $$invalidate(7, inviteCode = await base64URLEncode(pako.deflate(code, { level: 9 })));
    } catch (e) {
      console.error(e);
    }
    $$invalidate(12, currentAnimation = null);
  }
  const click_handler = () =&gt; $$invalidate(2, bioOpen = true);
  const click_handler_1 = () =&gt; performPointsActivity("chugEnergyDrink");
  const click_handler_2 = () =&gt; performPointsActivity("haveAColdShower");
  const click_handler_3 = () =&gt; performPointsActivity("grindAtTheGym");
  const click_handler_4 = () =&gt; getInviteCode();
  const func2 = () =&gt; {
    $$invalidate(3, levelUpOpen = true);
  };
  const func_1 = () =&gt; {
    $$invalidate(6, redeemOpen = true);
  };
  const func_2 = () =&gt; $$invalidate(2, bioOpen = false);
  const click_handler_5 = () =&gt; {
    $$invalidate(3, levelUpOpen = false);
    $$invalidate(4, levelUpSuccess = false);
    $$invalidate(2, bioOpen = false);
  };
  const click_handler_6 = () =&gt; {
    $$invalidate(3, levelUpOpen = false);
    $$invalidate(4, levelUpSuccess = false);
    $$invalidate(2, bioOpen = false);
    getInviteCode();
  };
  const func_3 = (isBurn) =&gt; {
    $$invalidate(5, gameFinished = isBurn);
    $$invalidate(4, levelUpSuccess = true);
  };
  const func_4 = () =&gt; {
    $$invalidate(3, levelUpOpen = false);
    $$invalidate(8, swapOpen = true);
  };
  const func_5 = () =&gt; {
    $$invalidate(3, levelUpOpen = false);
    $$invalidate(4, levelUpSuccess = false);
  };
  const click_handler_7 = () =&gt; {
    $$invalidate(9, successDialogOpen = false);
  };
  const func_6 = () =&gt; {
    $$invalidate(9, successDialogOpen = false);
  };
  const func_7 = () =&gt; {
    $$invalidate(6, redeemOpen = false);
  };
  const func_8 = () =&gt; {
    $$invalidate(6, redeemOpen = false);
  };
  const click_handler_8 = () =&gt; {
    navigator.clipboard.writeText(`${ACTIVATION_URL}?inviteCode=${inviteCode}`);
  };
  const func_9 = () =&gt; {
    $$invalidate(7, inviteCode = false);
  };
  const func_10 = () =&gt; {
    $$invalidate(8, swapOpen = false);
    $$invalidate(3, levelUpOpen = true);
  };
  const func_11 = () =&gt; {
    $$invalidate(8, swapOpen = false);
    $$invalidate(3, levelUpOpen = true);
  };
  $$self.$$.update = () =&gt; {
    if ($$self.$$.dirty[0] &amp; /*token*/
    1) {
      $$invalidate(13, cannotInvite = !token || Number(token.tokenId) &gt; 9999 || Number(token.morchiInfo.state.level) - Number(token.gameLevelActivationCodeUsed) &lt; 5);
    }
  };
  return [
    token,
    loading,
    bioOpen,
    levelUpOpen,
    levelUpSuccess,
    gameFinished,
    redeemOpen,
    inviteCode,
    swapOpen,
    successDialogOpen,
    pointsEarned,
    currentAction,
    currentAnimation,
    cannotInvite,
    performPointsActivity,
    getInviteCode,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    func2,
    func_1,
    func_2,
    click_handler_5,
    click_handler_6,
    func_3,
    func_4,
    func_5,
    click_handler_7,
    func_6,
    func_7,
    func_8,
    click_handler_8,
    func_9,
    func_10,
    func_11
  ];
}
class Play extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2, create_fragment$3, safe_not_equal, {}, null, [-1, -1]);
  }
}
function create_fragment$2(ctx) {
  let h1;
  return {
    c() {
      h1 = element("h1");
      h1.textContent = "404";
    },
    m(target, anchor) {
      insert(target, h1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(h1);
      }
    }
  };
}
class NotFound extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$2, safe_not_equal, {});
  }
}
function create_if_block(ctx) {
  let div1;
  let div0;
  let h3;
  let t0_value = getCharacterName(
    /*token*/
    ctx[0]
  ) + "";
  let t0;
  let t1;
  let t2_value = (
    /*token*/
    ctx[0].morchiInfo.state.level + ""
  );
  let t2;
  let t3;
  let biocard;
  let current;
  biocard = new BioCard({
    props: {
      token: (
        /*token*/
        ctx[0]
      ),
      isPublic: "true"
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      h3 = element("h3");
      t0 = text(t0_value);
      t1 = text(" - Level ");
      t2 = text(t2_value);
      t3 = space();
      create_component(biocard.$$.fragment);
      set_style(div0, "text-align", "center");
      attr(div1, "class", "row");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, h3);
      append(h3, t0);
      append(h3, t1);
      append(h3, t2);
      insert(target, t3, anchor);
      mount_component(biocard, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty &amp; /*token*/
      1) &amp;&amp; t0_value !== (t0_value = getCharacterName(
        /*token*/
        ctx2[0]
      ) + ""))
        set_data(t0, t0_value);
      if ((!current || dirty &amp; /*token*/
      1) &amp;&amp; t2_value !== (t2_value = /*token*/
      ctx2[0].morchiInfo.state.level + ""))
        set_data(t2, t2_value);
      const biocard_changes = {};
      if (dirty &amp; /*token*/
      1)
        biocard_changes.token = /*token*/
        ctx2[0];
      biocard.$set(biocard_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(biocard.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(biocard.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t3);
      }
      destroy_component(biocard, detaching);
    }
  };
}
function create_fragment$1(ctx) {
  let t;
  let loader;
  let current;
  let if_block = (
    /*token*/
    ctx[0] &amp;&amp; create_if_block(ctx)
  );
  loader = new Loader({ props: { show: (
    /*loading*/
    ctx[1]
  ) } });
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      mount_component(loader, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*token*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty &amp; /*token*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () =&gt; {
          if_block = null;
        });
        check_outros();
      }
      const loader_changes = {};
      if (dirty &amp; /*loading*/
      2)
        loader_changes.show = /*loading*/
        ctx2[1];
      loader.$set(loader_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      if (if_block)
        if_block.d(detaching);
      destroy_component(loader, detaching);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let token;
  let loading = true;
  context.data.subscribe(async (value) =&gt; {
    if (!value.token)
      return;
    $$invalidate(0, token = value.token);
    $$invalidate(1, loading = false);
  });
  return [token, loading];
}
class Info extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1, create_fragment$1, safe_not_equal, {});
  }
}
function create_fragment(ctx) {
  let div;
  let switch_instance;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*page*/
    ctx[0]
  );
  function switch_props(ctx2, dirty) {
    return {};
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(div, "id", "token-container");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          window,
          "hashchange",
          /*routeChange*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty &amp; /*page*/
      1 &amp;&amp; switch_value !== (switch_value = /*page*/
      ctx2[0])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () =&gt; {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (switch_instance)
        destroy_component(switch_instance);
      mounted = false;
      dispose();
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  const routingMap = { "#play": Play, "#info": Info };
  let page;
  function routeChange() {
    $$invalidate(0, page = routingMap[document.location.hash] || NotFound);
  }
  tokenscript.tokens.dataChanged = async (oldTokens, updatedTokens, cardId) =&gt; {
    context.setToken(updatedTokens.currentInstance);
    updatedTokens.currentInstance;
    routeChange();
  };
  return [page, routeChange];
}
class App extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {});
  }
}
new App({
  target: document.body
});


//]]&gt;</script>
<link rel="preconnect" href="https://fonts.googleapis.com"/>
<link rel="preconnect" href="https://fonts.gstatic.com"/>
<link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300;400;500;600;700;800;900&amp;display=swap" rel="stylesheet"/>


<style>
					/* <![CDATA[ */
					
* {
	font-family: "Rubik", sans-serif;
	box-sizing: border-box;
}

body {
	margin: 0;
	background-color: #292929;
	display: flex;
	align-items: center;
	justify-content: center;
	min-height: 100vh;
}

#token-container {
	background: #212121;
	color: #D4D3D3;
	width: 100%;
	max-width: 600px;
	padding: 10px;
	border-radius: 25px;
	position: relative;
	overflow: hidden;
}

h1 {
	font-size: 22px;
}

h2 {
	font-size: 20px;
}

h3 {
	font-size: 18px;
}

h5 {
	font-size: 16px;
	margin-bottom: 12px;
}

p.light {
	color: #545454;
}

.loader-modal {
	position: absolute;
	left: 0;
	top: 0;
	width: 100%;
	height: 100%;
}

.row {
	margin: 20px 10px;
}

.info-box {
	border-radius: 10px;
	padding: 8px 20px 8px 20px;
	background-color: #292929;
	min-height: 50px;
	display: flex;
	align-items: center;
}

.gradient-border {
	position: relative;
}

.gradient-border::before {
	content: "";
	position: absolute;
	inset: 0;
	border-radius: 10px;
	padding: 2px;
	background: radial-gradient(99.76% 578.75% at -10% -112.5%, #FF9482 31.78%, #FF5FB3 72.05%, #7D77FF 100%) /* warning: gradient uses a rotation that is not supported by CSS and may not behave as expected */;
	-webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
	-webkit-mask-composite: xor;
	mask-composite: exclude;
}

.btn {
	height: 40px;
	padding: 0 16px;
	border: none;
	border-radius: 10px;
	cursor: pointer;
}

.btn:disabled {
	cursor: not-allowed;
}

button::-moz-focus-inner {
	border: 0;
}

.btn span {
	font-size: 14px;
	font-weight: 600;
}

.btn-primary {
	background: linear-gradient(106.84deg, rgba(255, 140, 74, 0.9) 6.22%, rgba(255, 96, 95, 0.9) 90.19%);
	border: none;
}

.btn-primary:hover {
	background: linear-gradient(106.84deg, #FF8C4A 6.22%, #FF605F 90.19%) !important;
	border: none;
}

.btn-primary:disabled {
	background: #4A4747 !important;
	border: none !important;
}

.btn-primary span {
	color: white;
}

.btn-secondary {
	border: 1px solid rgb(255, 88, 36);
	border-color: rgb(255, 88, 36) !important;
	background: transparent;
}

.btn-secondary:disabled {
	border: 1px solid #5C5857 !important;
	background: #212121 !important;
}

.btn-secondary span {
	background-image: linear-gradient(106.84deg, rgb(255, 140, 74) 6.22%, rgb(255, 96, 95) 90.19%);
	background-clip: text;
	color: transparent;
}

.btn-secondary:disabled span {
	color: #83807F !important;
	background-image: unset !important;
}

.btn-secondary:hover {
	border: 1px solid rgb(255, 88, 36);
	background: #FF58240F;
}

input, textarea {
	border-radius: 12px;
	background-color: #343434;
	border: 1px solid #343434;
	outline: 0;
	color: #fff;
	padding: 5px;
}

input:focus, textarea:focus {
	border: 1px solid #C07BFF;
}

/* Chrome, Safari, Edge, Opera */
input::-webkit-outer-spin-button,
input::-webkit-inner-spin-button {
	-webkit-appearance: none;
	margin: 0;
}

:focus {outline:none;}
::-moz-focus-inner {border:0;}

/* Firefox */
input[type=number] {
	-moz-appearance: textfield;
}

.task-hint-text {
	text-align: center;
	margin-top: 8px;
	width: 100%;
	display: inline-block;
	background: linear-gradient(106.84deg, #FF8C4A 6.22%, #FF605F 90.19%);
	background-clip: text;
	-webkit-text-fill-color: transparent
}

					/* ]]> */
				</style></ts:viewContent>

		<ts:card name="Play" origins="Token" type="token">
			<ts:label>
				<ts:string xml:lang="en">Play Morchi</ts:string>
			</ts:label>
			<ts:attribute name="redeemAmt">
				<ts:type><ts:syntax>1.3.6.1.4.1.1466.115.121.1.27</ts:syntax></ts:type>
				<ts:label>
					<ts:string xml:lang="en">Redeem Amount</ts:string>
				</ts:label>
				<ts:origins>
					<ts:user-entry as="uint"/>
				</ts:origins>
			</ts:attribute>
			<ts:view xmlns="http://www.w3.org/1999/xhtml" fullScreen="true" urlFragment="play" xml:lang="en">
				<ts:viewContent name="common"/>
			</ts:view>
		</ts:card>

		<ts:card name="Info" origins="Token" type="public">
			<ts:label>
				<ts:string xml:lang="en">Morchi's Bio</ts:string>
			</ts:label>
			<ts:view xmlns="http://www.w3.org/1999/xhtml" fullScreen="true" urlFragment="info" xml:lang="en">
				<ts:viewContent name="common"/>
			</ts:view>
		</ts:card>

	</ts:cards>

	<ts:attribute name="morchiInfo">
		<ts:type><ts:syntax>1.3.6.1.4.1.1466.115.121.1.27</ts:syntax></ts:type>
		<ts:label>
			<ts:string xml:lang="en">Morchi Info</ts:string>
		</ts:label>
		<ts:origins>
			<ethereum:call as="abi" contract="MorchiScore" function="getMorchiInfo">
				<ts:data>
					<ts:uint256 ref="tokenId"/>
				</ts:data>
			</ethereum:call>
		</ts:origins>
	</ts:attribute>

	<ts:attribute name="gameLevelActivationCodeUsed">
		<ts:type><ts:syntax>1.3.6.1.4.1.1466.115.121.1.27</ts:syntax></ts:type>
		<ts:label>
			<ts:string xml:lang="en">Game Level for which Activation Code Used</ts:string>
		</ts:label>
		<ts:origins>
			<ethereum:call as="uint" contract="Token" function="gameLevelActivationCodeUsed">
				<ts:data>
					<ts:uint256 ref="tokenId"/>
				</ts:data>
			</ethereum:call>
		</ts:origins>
	</ts:attribute>

	<ts:transaction name="chugEnergyDrink">
		<ethereum:transaction as="uint" contract="MorchiScore" function="chugEnergyDrink">
			<ts:data>
				<ts:uint256 ref="tokenId"/>
			</ts:data>
		</ethereum:transaction>
	</ts:transaction>

	<ts:transaction name="haveAColdShower">
		<ethereum:transaction as="uint" contract="MorchiScore" function="haveAColdShower">
			<ts:data>
				<ts:uint256 ref="tokenId"/>
			</ts:data>
		</ethereum:transaction>
	</ts:transaction>

	<ts:transaction name="grindAtTheGym">
		<ethereum:transaction as="uint" contract="MorchiScore" function="grindAtTheGym">
			<ts:data>
				<ts:uint256 ref="tokenId"/>
			</ts:data>
		</ethereum:transaction>
	</ts:transaction>

	<ts:transaction name="levelUp">
		<ethereum:transaction as="uint" contract="MorchiScore" function="levelUp">
			<ts:data>
				<ts:uint256 ref="tokenId"/>
			</ts:data>
		</ethereum:transaction>
	</ts:transaction>

	<ts:transaction name="approveSUT">
		<ethereum:transaction as="uint" contract="SUTToken" function="approve">
			<ts:data>
				<ts:address ref="contractAddress_MorchiScore"/>
				<ts:uint256 local-ref="approveAmt"/>
			</ts:data>
		</ethereum:transaction>
	</ts:transaction>

	<ts:transaction name="withdrawPointsToSUT">
		<ethereum:transaction as="uint" contract="MorchiScore" function="withdrawPointsToSUT">
			<ts:data>
				<ts:uint256 ref="tokenId"/>
				<ts:uint256 local-ref="redeemAmt"/>
			</ts:data>
		</ethereum:transaction>
	</ts:transaction>

	<ts:transaction name="approveGMTForSwap">
		<ethereum:transaction as="uint" contract="GMTToken" function="approve">
			<ts:data>
				<ts:address ref="contractAddress_DooarSwapRouter"/>
				<ts:uint256 local-ref="approveAmt"/>
			</ts:data>
		</ethereum:transaction>
	</ts:transaction>

	<ts:transaction name="swapExactTokensForTokens">
		<ethereum:transaction as="uint" contract="DooarSwapRouter" function="swapExactTokensForTokens">
			<ts:data>
				<ts:uint256 local-ref="amountIn"/>
				<ts:uint256 local-ref="amountOutMin"/>
				<ts:struct local-ref="path"/>
				<ts:address ref="ownerAddress"/>
				<ts:uint256 local-ref="deadline"/>
			</ts:data>
		</ethereum:transaction>
	</ts:transaction>
	<ts:transaction name="swapTokensForExactTokens">
		<ethereum:transaction as="uint" contract="DooarSwapRouter" function="swapTokensForExactTokens">
			<ts:data>
				<ts:uint256 local-ref="amountOut"/>
				<ts:uint256 local-ref="amountInMax"/>
				<ts:struct local-ref="path"/>
				<ts:address ref="ownerAddress"/>
				<ts:uint256 local-ref="deadline"/>
			</ts:data>
		</ethereum:transaction>
	</ts:transaction>

	<ts:transaction name="approveNFTBurn">
		<ethereum:transaction as="uint" contract="Token" function="approve">
			<ts:data>
				<ts:address ref="contractAddress_MorchiScore"/>
				<ts:uint256 ref="tokenId"/>
			</ts:data>
		</ethereum:transaction>
	</ts:transaction>
<ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#"><ds:SignedInfo><ds:CanonicalizationMethod Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315"/><ds:SignatureMethod Algorithm="http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256"/><ds:Reference><ds:Transforms><ds:Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/><ds:Transform Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315"/></ds:Transforms><ds:DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/><ds:DigestValue>eWU2Dlr1bMcy1AopyVTK1CwvsmDuKgq5Gv+IcL03Wmc=</ds:DigestValue></ds:Reference></ds:SignedInfo><ds:SignatureValue>HNQKvL2sg0CDQWxsZBFGJiX8drKIlypLu3cXPgrqj9Dt8FX2f7z1PasjfsTNb6TcbFTiwZbm7p7YKTdSJyAYRA==</ds:SignatureValue><ds:KeyInfo><ds:KeyValue><ecdsa:ECDSAKeyValue xmlns:ecdsa="http://www.w3.org/2001/04/xmldsig-more#"><ecdsa:DomainParameters><ecdsa:NamedCurve URI="urn:oid:1.3.132.0.10"/></ecdsa:DomainParameters><ecdsa:PublicKey><ecdsa:X>4AQVAWD3IY5tHmASnBn38RKHrVTFodVnV4IAFStb3sg=</ecdsa:X><ecdsa:Y>ZmUq25j5e065TtcZyDY7FqHBTk8aJ2Jc/Kq5kHYq2mQ=</ecdsa:Y></ecdsa:PublicKey></ecdsa:ECDSAKeyValue></ds:KeyValue></ds:KeyInfo></ds:Signature></ts:token>